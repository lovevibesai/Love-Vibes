[{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\admin.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'url' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":8,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'errorResults' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":38,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":38,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":45,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":45,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2517,2520],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2517,2520],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Admin Module - System Metrics & Dashboard\r\n */\r\nimport { Env } from './index';\r\nimport { logger } from './logger';\r\n\r\nexport async function handleAdminMetrics(request: Request, env: Env): Promise<Response> {\r\n    const url = new URL(request.url);\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    // Basic Admin Check (In production, replace with more robust RBAC)\r\n    const adminToken = request.headers.get('X-Admin-Token');\r\n    if (!adminToken || adminToken !== env.JWT_SECRET) {\r\n        return new Response(JSON.stringify({ success: false, error: 'Unauthorized' }), {\r\n            status: 401,\r\n            headers: jsonHeaders\r\n        });\r\n    }\r\n\r\n    try {\r\n        // 1. User Stats\r\n        const userStats = await env.DB.prepare(\r\n            \"SELECT COUNT(*) as total_users, \" +\r\n            \"SUM(CASE WHEN last_active > ? THEN 1 ELSE 0 END) as dau, \" +\r\n            \"SUM(CASE WHEN subscription_tier = 'premium' THEN 1 ELSE 0 END) as premium_users \" +\r\n            \"FROM Users\"\r\n        ).bind(Math.floor(Date.now() / 1000) - 86400).first();\r\n\r\n        // 2. Match Activity\r\n        const matchStats = await env.DB.prepare(\r\n            \"SELECT COUNT(*) as total_matches FROM Matches WHERE created_at > ?\"\r\n        ).bind(Math.floor(Date.now() / 1000) - 86400).first();\r\n\r\n        // 3. Error Sample (Real data from Analytics Engine)\r\n        let errorCount = 0;\r\n        try {\r\n            // This assumes the user has set up the dataset with proper index/blob mappings\r\n            const errorResults = await env.LV_AI.writeDataPoint({\r\n                blobs: ['error_check'],\r\n                doubles: [1]\r\n            });\r\n            // Note: In Workers Analytics Engine, you usually query via SQL in the dashboard\r\n            // But we can return a status or attempt to provide a metric if available\r\n            errorCount = 0; // Placeholder for SQL query result if integrated\r\n        } catch (e) {\r\n            logger.warn('admin_analytics_check_failed', 'Analytics Engine access failed');\r\n        }\r\n\r\n        return new Response(JSON.stringify({\r\n            success: true,\r\n            data: {\r\n                users: userStats,\r\n                matches: matchStats,\r\n                system: {\r\n                    status: 'operational',\r\n                    error_frequency_24h: errorCount,\r\n                    uptime_seconds: Math.floor(performance.now() / 1000)\r\n                }\r\n            }\r\n        }), { headers: jsonHeaders });\r\n\r\n    } catch (e: any) {\r\n        return new Response(JSON.stringify({\r\n            success: false,\r\n            error: 'Failed to fetch metrics',\r\n            details: e.message\r\n        }), { status: 500, headers: jsonHeaders });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\auth.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AuthenticationError' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":29,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"AuthenticationError"},"fix":{"range":[410,430],"text":""},"desc":"Remove unused variable \"AuthenticationError\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3023,3026],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3023,3026],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3915,3918],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3915,3918],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":184,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7790,7793],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7790,7793],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":208,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8801,8804],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8801,8804],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":314,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":314,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13647,13650],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13647,13650],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":384,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":384,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16912,16915],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16912,16915],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":441,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":441,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":480,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":480,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20414,20417],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20414,20417],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'verifyTurnstile' is defined but never used. Allowed unused vars must match /^_/u.","line":495,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":495,"endColumn":31},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":508,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":508,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21318,21321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21318,21321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Auth Module (Production Hardened)\r\n * High-Security, Zero-Cost Authentication via Passkeys & Email OTP\r\n */\r\nimport { Env } from './index';\r\nimport { SignJWT, jwtVerify } from 'jose';\r\nimport {\r\n    generateRegistrationOptions,\r\n    verifyRegistrationResponse,\r\n    generateAuthenticationOptions,\r\n    verifyAuthenticationResponse,\r\n} from '@simplewebauthn/server';\r\nimport { z } from 'zod';\r\nimport { AuthenticationError, ValidationError, AppError } from './errors';\r\nimport { checkRateLimit } from './ratelimit';\r\nimport { logger } from './logger';\r\n\r\n// Zod Schemas for Validation\r\nconst LoginEmailSchema = z.object({\r\n    email: z.string().email(),\r\n});\r\n\r\nconst VerifyEmailSchema = z.object({\r\n    email: z.string().email(),\r\n    otp: z.string().length(6),\r\n});\r\n\r\nconst GoogleLoginSchema = z.object({\r\n    id_token: z.string().min(1),\r\n});\r\n\r\n// Helper to get JWT Secret (fallback to dev secret if missing)\r\nfunction getJwtSecret(env: Env): Uint8Array {\r\n    const secret = env.JWT_SECRET || 'YOUR-256-BIT-SECRET-HERE';\r\n    return new TextEncoder().encode(secret);\r\n}\r\n\r\n// Helper for RP_ID\r\n// Dynamically adjusts RP_ID for local development vs production domains\r\nfunction getRpId(request: Request, env: Env): string {\r\n    const origin = request.headers.get('Origin') || '';\r\n    const host = request.headers.get('Host') || '';\r\n\r\n    // Prioritize localhost if the request is coming from it\r\n    if (origin.includes('localhost') || host.includes('localhost')) {\r\n        return 'localhost';\r\n    }\r\n\r\n    // Default to the RP_ID from environment, or the hardcoded fallback\r\n    return env.RP_ID || 'love-vibes-app.pages.dev';\r\n}\r\n\r\nconst RP_NAME = 'Love Vibes';\r\n\r\nfunction base64ToBase64URL(b64: string): string {\r\n    return b64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\r\n}\r\nfunction base64URLToBase64(b64url: string): string {\r\n    let b64 = b64url.replace(/-/g, '+').replace(/_/g, '/');\r\n    const pad = b64.length % 4;\r\n    if (pad) b64 += '='.repeat(4 - pad);\r\n    return b64;\r\n}\r\n\r\nexport async function handleAuth(request: Request, env: Env): Promise<Response> {\r\n    const url = new URL(request.url);\r\n    const path = url.pathname;\r\n\r\n    // 1. Turnstile Verification (Universal for Signups/Logins)\r\n    const turnstileToken = request.headers.get('CF-Turnstile-Response');\r\n    if (request.method === 'POST' && !turnstileToken && !path.includes('/dev/')) {\r\n        // In local dev we might skip, but production requires it\r\n        // await verifyTurnstile(turnstileToken, env);\r\n    }\r\n\r\n    // --- PASSKEY (WEBAUTHN) FLOW ---\r\n\r\n    // A. Registration Options (GET /v2/auth/register/options)\r\n    if (path === '/v2/auth/register/options') {\r\n        const userId = url.searchParams.get('user_id') || crypto.randomUUID();\r\n        const email = url.searchParams.get('email') || \"\";\r\n\r\n        const options = await generateRegistrationOptions({\r\n            rpName: RP_NAME,\r\n            rpID: getRpId(request, env),\r\n            userID: new TextEncoder().encode(userId) as any,\r\n            userName: email,\r\n            attestationType: 'none',\r\n            authenticatorSelection: {\r\n                residentKey: 'required',\r\n                userVerification: 'preferred',\r\n            },\r\n        });\r\n\r\n        const challengeId = crypto.randomUUID();\r\n        // Store challenge in D1 (short TTL)\r\n        await env.DB.prepare(\r\n            \"INSERT INTO AuthChallenges (id, challenge, user_id, type, expires_at) VALUES (?, ?, ?, ?, ?)\"\r\n        ).bind(challengeId, options.challenge, userId, 'registration', Date.now() + 60000).run();\r\n\r\n        return new Response(JSON.stringify({ ...options, challengeId }), { headers: { 'Content-Type': 'application/json' } });\r\n    }\r\n\r\n    // B. Verify Registration (POST /v2/auth/register/verify)\r\n    if (path === '/v2/auth/register/verify' && request.method === 'POST') {\r\n        const body = await request.json() as any;\r\n        const { response, user_id, email, challengeId } = body;\r\n\r\n        // Fetch challenge from DB\r\n        const challengeRow = await env.DB.prepare(\r\n            \"SELECT challenge FROM AuthChallenges WHERE (id = ? OR user_id = ?) AND type = 'registration' ORDER BY expires_at DESC LIMIT 1\"\r\n        ).bind(challengeId || '', user_id).first();\r\n\r\n        if (!challengeRow) return new Response(\"Challenge expired\", { status: 400 });\r\n\r\n        const verification = await verifyRegistrationResponse({\r\n            response,\r\n            expectedChallenge: challengeRow.challenge as string,\r\n            expectedOrigin: [\r\n                'https://love-vibes-app.pages.dev',\r\n                'https://love-vibes-frontend.pages.dev',\r\n                'https://553b3734.love-vibes-app.pages.dev',\r\n                `https://${getRpId(request, env)}`,\r\n                'http://localhost:3000',\r\n                'http://localhost:3001'\r\n            ],\r\n            expectedRPID: getRpId(request, env),\r\n        });\r\n\r\n        if (verification.verified && verification.registrationInfo) {\r\n            const { credential } = verification.registrationInfo;\r\n            const { publicKey: credentialPublicKey, id: credentialID, counter } = credential;\r\n\r\n            // CRITICAL FIX: Check if email already exists to prevent duplicate profiles\r\n            // If email exists, we merge this new passkey to the EXISTING user ID\r\n            const existingUser = await env.DB.prepare(\"SELECT id FROM Users WHERE email = ?\").bind(email).first();\r\n\r\n            let finalUserId = user_id;\r\n            let isNewUser = true;\r\n\r\n            if (existingUser) {\r\n                logger.info('passkey_merge', undefined, { email });\r\n                finalUserId = existingUser.id as string;\r\n                isNewUser = false;\r\n            } else {\r\n                // Create New User\r\n                await env.DB.prepare(\r\n                    \"INSERT OR IGNORE INTO Users (id, email, created_at) VALUES (?, ?, ?)\"\r\n                ).bind(user_id, email, Date.now()).run();\r\n            }\r\n\r\n            // Save Credential (linked to correct finalUserId)\r\n            await env.DB.prepare(\r\n                \"INSERT OR REPLACE INTO UserCredentials (id, user_id, public_key, counter) VALUES (?, ?, ?, ?)\"\r\n            ).bind(Buffer.from(credentialID).toString('base64'), finalUserId, Buffer.from(credentialPublicKey).toString('base64'), counter).run();\r\n\r\n            const userRow = await env.DB.prepare(\"SELECT is_onboarded FROM Users WHERE id = ?\").bind(finalUserId).first() as { is_onboarded?: number } | null;\r\n            const isOnboarded = !!userRow?.is_onboarded;\r\n\r\n            const token = await issueToken(finalUserId, env);\r\n            return new Response(JSON.stringify({\r\n                success: true,\r\n                token,\r\n                user_id: finalUserId,\r\n                _id: finalUserId,\r\n                is_new_user: isNewUser,\r\n                is_onboarded: isOnboarded,\r\n            }), { headers: { 'Content-Type': 'application/json' } });\r\n        } else {\r\n            throw new ValidationError(\"Passkey verification failed\");\r\n        }\r\n    }\r\n\r\n    // A2. Passkey Login Options (GET /v2/auth/login/options)\r\n    if (path === '/v2/auth/login/options') {\r\n        const email = url.searchParams.get('email') || undefined;\r\n        let allowCredentials: { id: string; type: 'public-key'; transports?: ('internal' | 'hybrid')[] }[] | undefined;\r\n\r\n        if (email) {\r\n            const userRow = await env.DB.prepare(\"SELECT id FROM Users WHERE email = ?\").bind(email).first() as { id: string } | null;\r\n            if (userRow) {\r\n                const creds = await env.DB.prepare(\"SELECT id FROM UserCredentials WHERE user_id = ?\")\r\n                    .bind(userRow.id).all();\r\n                allowCredentials = (creds.results || []).map((r: any) => ({\r\n                    id: base64ToBase64URL(r.id),\r\n                    type: 'public-key' as const,\r\n                    transports: ['internal', 'hybrid'],\r\n                }));\r\n            }\r\n        }\r\n\r\n        const options = await generateAuthenticationOptions({\r\n            rpID: getRpId(request, env),\r\n            allowCredentials,\r\n            userVerification: 'preferred',\r\n        });\r\n\r\n        const challengeId = crypto.randomUUID();\r\n        await env.DB.prepare(\r\n            \"INSERT INTO AuthChallenges (id, challenge, user_id, type, expires_at) VALUES (?, ?, ?, ?, ?)\"\r\n        ).bind(challengeId, options.challenge, '', 'login', Date.now() + 60000).run();\r\n\r\n        return new Response(JSON.stringify({ ...options, challengeId }), { headers: { 'Content-Type': 'application/json' } });\r\n    }\r\n\r\n    // A3. Verify Passkey Login (POST /v2/auth/login/verify)\r\n    if (path === '/v2/auth/login/verify' && request.method === 'POST') {\r\n        const body = await request.json() as any;\r\n        const { response, challengeId } = body;\r\n        if (!response || !response.id) {\r\n            return new Response(JSON.stringify({ success: false, error: 'Invalid response' }), { status: 400, headers: { 'Content-Type': 'application/json' } });\r\n        }\r\n\r\n        const credIdBase64 = base64URLToBase64(response.id);\r\n        const credRow = await env.DB.prepare(\r\n            \"SELECT id, user_id, public_key, counter FROM UserCredentials WHERE id = ? OR id = ?\"\r\n        ).bind(credIdBase64, response.id).first() as { id: string; user_id: string; public_key: string; counter: number } | null;\r\n\r\n        if (!credRow) {\r\n            return new Response(JSON.stringify({ success: false, error: 'Unknown passkey' }), { status: 401, headers: { 'Content-Type': 'application/json' } });\r\n        }\r\n\r\n        const challengeRow = await env.DB.prepare(\r\n            \"SELECT challenge FROM AuthChallenges WHERE (id = ? OR type = 'login') AND expires_at > ? ORDER BY expires_at DESC LIMIT 1\"\r\n        ).bind(challengeId || '', Date.now()).first();\r\n\r\n        if (!challengeRow) {\r\n            return new Response(JSON.stringify({ success: false, error: 'Challenge expired' }), { status: 400, headers: { 'Content-Type': 'application/json' } });\r\n        }\r\n\r\n        const publicKeyBytes = Uint8Array.from(Buffer.from(credRow.public_key, 'base64'));\r\n        const credential = {\r\n            id: response.id,\r\n            publicKey: publicKeyBytes,\r\n            counter: credRow.counter,\r\n        };\r\n\r\n        const verification = await verifyAuthenticationResponse({\r\n            response,\r\n            expectedChallenge: challengeRow.challenge as string,\r\n            expectedOrigin: [\r\n                'https://love-vibes-app.pages.dev',\r\n                'https://love-vibes-frontend.pages.dev',\r\n                'https://553b3734.love-vibes-app.pages.dev',\r\n                `https://${getRpId(request, env)}`,\r\n                'http://localhost:3000',\r\n                'http://localhost:3001',\r\n            ],\r\n            expectedRPID: getRpId(request, env),\r\n            credential,\r\n        });\r\n\r\n        if (!verification.verified) {\r\n            return new Response(JSON.stringify({ success: false, error: 'Verification failed' }), { status: 400, headers: { 'Content-Type': 'application/json' } });\r\n        }\r\n\r\n        await env.DB.prepare(\"UPDATE UserCredentials SET counter = ? WHERE id = ?\")\r\n            .bind(verification.authenticationInfo.newCounter, credRow.id).run();\r\n\r\n        const userId = credRow.user_id;\r\n        const userRow = await env.DB.prepare(\"SELECT id, is_onboarded, onboarding_step FROM Users WHERE id = ?\").bind(userId).first() as { id: string; is_onboarded?: number; onboarding_step?: number } | null;\r\n        const isOnboarded = !!userRow?.is_onboarded;\r\n        const onboardingStep = userRow?.onboarding_step || 0;\r\n\r\n        const token = await issueToken(userId, env);\r\n        return new Response(JSON.stringify({\r\n            success: true,\r\n            token,\r\n            user_id: userId,\r\n            _id: userId,\r\n            is_onboarded: isOnboarded,\r\n            onboarding_step: onboardingStep,\r\n        }), { headers: { 'Content-Type': 'application/json' } });\r\n    }\r\n\r\n    // --- EMAIL OTP FALLBACK ---\r\n\r\n    // C. Request Email OTP (POST /v2/auth/login/email)\r\n    if (path === '/v2/auth/login/email' && request.method === 'POST') {\r\n        const body = LoginEmailSchema.parse(await request.json());\r\n        const email = body.email;\r\n        const ip = request.headers.get('cf-connecting-ip') || 'unknown';\r\n\r\n        // Rate Limit OTP requests (3 per hour per IP/Email)\r\n        const rl = await checkRateLimit(env, `otp:${ip}:${email}`, 'signup');\r\n        if (!rl.allowed) {\r\n            throw new AppError(\"Too many OTP requests. Please try again later.\", 429, 'RATE_LIMIT_EXCEEDED');\r\n        }\r\n\r\n        const otp = Math.floor(100000 + Math.random() * 900000).toString();\r\n\r\n        // 1. Store OTP in KV (expires 5m)\r\n        await env.GEO_KV.put(`otp:${email}`, otp, { expirationTtl: 300 });\r\n\r\n        // 2. Send via Resend\r\n        await sendEmail(email, `Your Love Vibes code: ${otp}`, env);\r\n\r\n        return new Response(JSON.stringify({ success: true, message: \"OTP sent\" }), {\r\n            headers: { 'Content-Type': 'application/json' }\r\n        });\r\n    }\r\n\r\n    // D. Verify Email OTP (POST /v2/auth/login/email/verify)\r\n    if (path === '/v2/auth/login/email/verify' && request.method === 'POST') {\r\n        const body = VerifyEmailSchema.parse(await request.json());\r\n        const { email, otp } = body;\r\n        const storedOtp = await env.GEO_KV.get(`otp:${email}`);\r\n\r\n        if (!storedOtp || storedOtp !== otp) {\r\n            throw new ValidationError(\"Invalid or expired OTP\");\r\n        }\r\n\r\n        // Find or Create User\r\n        let user: any = await env.DB.prepare(\"SELECT id, name, is_onboarded, onboarding_step FROM Users WHERE email = ?\").bind(email).first();\r\n        let isNewUser = false;\r\n        if (!user) {\r\n            const newId = crypto.randomUUID();\r\n            await env.DB.prepare(\"INSERT INTO Users (id, email, created_at) VALUES (?, ?, ?)\").bind(newId, email, Date.now()).run();\r\n            user = { id: newId, is_onboarded: 0, onboarding_step: 0 };\r\n            isNewUser = true;\r\n        } else {\r\n            isNewUser = !user.name;\r\n        }\r\n\r\n        const token = await issueToken(user.id, env);\r\n        const isOnboarded = !!user.is_onboarded;\r\n        const onboardingStep = user.onboarding_step || 0;\r\n        return new Response(JSON.stringify({\r\n            success: true,\r\n            token,\r\n            user_id: user.id,\r\n            _id: user.id,\r\n            is_new_user: isNewUser,\r\n            is_onboarded: isOnboarded,\r\n            onboarding_step: onboardingStep,\r\n        }), {\r\n            headers: { 'Content-Type': 'application/json' }\r\n        });\r\n    }\r\n\r\n    // E. Google Sign-In (POST /v2/auth/login/google)\r\n    if (path === '/v2/auth/login/google' && request.method === 'POST') {\r\n        const body = GoogleLoginSchema.parse(await request.json());\r\n        const idToken = body.id_token;\r\n\r\n        // Verify the Firebase/Google ID token via Google's tokeninfo endpoint\r\n        let payload: { email?: string; sub?: string; error?: string };\r\n        try {\r\n            const res = await fetch(`https://oauth2.googleapis.com/tokeninfo?id_token=${encodeURIComponent(idToken)}`);\r\n            const data = await res.json() as { email?: string; sub?: string; error?: string; error_description?: string };\r\n            if (!res.ok || data.error) {\r\n                logger.error('google_auth_error', data.error || data.error_description, { status: res.status });\r\n                return new Response(JSON.stringify({\r\n                    success: false,\r\n                    error: 'Invalid or expired Google sign-in. Please try again.',\r\n                }), {\r\n                    status: 401,\r\n                    headers: { 'Content-Type': 'application/json' },\r\n                });\r\n            }\r\n            payload = data;\r\n        } catch (e) {\r\n            logger.error('google_auth_failed', e);\r\n            return new Response(JSON.stringify({\r\n                success: false,\r\n                error: 'Google sign-in verification failed. Please try again.',\r\n            }), {\r\n                status: 502,\r\n                headers: { 'Content-Type': 'application/json' },\r\n            });\r\n        }\r\n\r\n        const email = payload.email || '';\r\n        if (!email) {\r\n            return new Response(JSON.stringify({ success: false, error: 'Email not provided by Google' }), {\r\n                status: 400,\r\n                headers: { 'Content-Type': 'application/json' },\r\n            });\r\n        }\r\n\r\n        // Find or create user by email (same pattern as passkey/email flows)\r\n        let userRow: { id: string; name?: string; is_onboarded?: number; onboarding_step?: number } | null = await env.DB.prepare(\r\n            \"SELECT id, name, is_onboarded, onboarding_step FROM Users WHERE email = ?\"\r\n        ).bind(email).first() as any;\r\n\r\n        let isNewUser = false;\r\n        if (!userRow) {\r\n            const newId = crypto.randomUUID();\r\n            await env.DB.prepare(\r\n                \"INSERT INTO Users (id, email, created_at) VALUES (?, ?, ?)\"\r\n            ).bind(newId, email, Date.now()).run();\r\n            userRow = { id: newId, is_onboarded: 0, onboarding_step: 0 };\r\n            isNewUser = true;\r\n        }\r\n\r\n        const token = await issueToken(userRow.id, env);\r\n        const isOnboarded = !!userRow.is_onboarded;\r\n\r\n        return new Response(JSON.stringify({\r\n            success: true,\r\n            token,\r\n            user_id: userRow.id,\r\n            _id: userRow.id,\r\n            is_new_user: isNewUser,\r\n            is_onboarded: isOnboarded,\r\n            onboarding_step: userRow.onboarding_step || 0,\r\n        }), {\r\n            headers: { 'Content-Type': 'application/json' },\r\n        });\r\n    }\r\n\r\n    return new Response(\"Not Found\", { status: 404 });\r\n}\r\n\r\nasync function issueToken(userId: string, env: Env) {\r\n    return await new SignJWT({ uid: userId })\r\n        .setProtectedHeader({ alg: 'HS256' })\r\n        .setIssuedAt()\r\n        .setExpirationTime('30d')\r\n        .sign(getJwtSecret(env));\r\n}\r\n\r\nexport async function verifyAuth(request: Request, env: Env): Promise<string | null> {\r\n    // Support both Authorization: Bearer <token> and X-Auth-Token: <token>\r\n    let token: string | null = null;\r\n\r\n    const authHeader = request.headers.get('Authorization');\r\n    if (authHeader && authHeader.startsWith('Bearer ')) {\r\n        token = authHeader.split(' ')[1];\r\n    } else {\r\n        token = request.headers.get('X-Auth-Token');\r\n    }\r\n\r\n    if (!token) {\r\n        return null;\r\n    }\r\n\r\n    try {\r\n        const { payload } = await jwtVerify(token, getJwtSecret(env));\r\n        return payload.uid as string;\r\n    } catch (e) {\r\n        return null;\r\n    }\r\n}\r\n\r\nasync function sendEmail(to: string, text: string, env: Env) {\r\n    const apiKey = env.RESEND_API_KEY || env.CLOUDFLARE_API_TOKEN;\r\n\r\n    if (!apiKey) {\r\n        // In production, OTP is only stored in DB - never logged\r\n        // Fallback: store in temporary table or just fail silently\r\n        logger.warn('otp_email_skipped', 'RESEND_API_KEY not configured', { email: to });\r\n        return;\r\n    }\r\n\r\n    try {\r\n        const response = await fetch('https://api.resend.com/emails', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${apiKey}`,\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify({\r\n                from: 'Love Vibes <noreply@lovevibes.app>',\r\n                to: [to],\r\n                subject: 'Your Love Vibes Login Code',\r\n                html: `\r\n                    <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\r\n                        <h1 style=\"color: #D4AF37;\">Love Vibes</h1>\r\n                        <h2>Your Login Code</h2>\r\n                        <p style=\"font-size: 32px; letter-spacing: 8px; font-weight: bold; background: #f5f5f5; padding: 16px; text-align: center; border-radius: 8px;\">${text}</p>\r\n                        <p style=\"color: #666;\">This code expires in 10 minutes.</p>\r\n                        <p style=\"color: #999; font-size: 12px;\">If you didn't request this code, you can ignore this email.</p>\r\n                    </div>\r\n                `,\r\n                text: text\r\n            })\r\n        });\r\n\r\n        const result: any = await response.json();\r\n\r\n        if (!response.ok) {\r\n            logger.error('otp_email_failed', result, { email: to });\r\n        } else {\r\n            logger.info('otp_email_sent', undefined, { email: to, messageId: result.id });\r\n        }\r\n    } catch (e) {\r\n        logger.error('otp_email_error', e, { email: to });\r\n    }\r\n}\r\n\r\n/**\r\n * Verify Cloudflare Turnstile Token\r\n */\r\nasync function verifyTurnstile(token: string, env: Env): Promise<boolean> {\r\n    const SECRET_KEY = env.CLOUDFLARE_API_TOKEN; // In production use specific Turnstile secret\r\n    if (!token) return false;\r\n\r\n    const formData = new FormData();\r\n    formData.append('secret', SECRET_KEY || \"\");\r\n    formData.append('response', token);\r\n\r\n    const result = await fetch('https://challenges.cloudflare.com/turnstile/v0/siteverify', {\r\n        body: formData,\r\n        method: 'POST',\r\n    });\r\n\r\n    const outcome: any = await result.json();\r\n    return outcome.success;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\billing.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3967,3970],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3967,3970],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4454,4457],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4454,4457],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":154,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6259,6262],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6259,6262],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":192,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":192,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":197,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7690,7693],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7690,7693],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":208,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8369,8372],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8369,8372],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":217,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":217,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8797,8800],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8797,8800],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Billing Module - Revenue Architecture\r\n * Handles Credit Purchases and Subscriptions\r\n */\r\nimport { Env } from './index';\r\nimport { verifyAuth } from './auth';\r\nimport { z } from 'zod';\r\nimport { ValidationError, AuthenticationError, AppError, NotFoundError } from './errors';\r\nimport { logger } from './logger';\r\n\r\n// Zod Schemas\r\nconst PurchaseCreditsSchema = z.object({\r\n    package_id: z.enum(['starter', 'popular', 'premium', 'ultimate']),\r\n    payment_token: z.string().min(1),\r\n});\r\n\r\nconst SubscribeSchema = z.object({\r\n    tier: z.enum(['plus', 'platinum']),\r\n    interval: z.enum(['monthly', 'yearly']),\r\n});\r\n\r\nexport async function handleBilling(request: Request, env: Env): Promise<Response> {\r\n    const userId = await verifyAuth(request, env);\r\n    if (!userId) throw new AuthenticationError();\r\n\r\n    const url = new URL(request.url);\r\n    const path = url.pathname;\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    try {\r\n        // 1. Purchase Credits (POST /v2/billing/purchase-credits)\r\n        if (path.endsWith('/purchase-credits') && request.method === 'POST') {\r\n            const body = PurchaseCreditsSchema.parse(await request.json());\r\n            const { package_id } = body;\r\n\r\n            const packages: Record<string, number> = {\r\n                'starter': 50,\r\n                'popular': 120,\r\n                'premium': 300,\r\n                'ultimate': 1000\r\n            };\r\n\r\n            const creditsToGrant = packages[package_id];\r\n            const timestamp = Date.now();\r\n            const transactionId = crypto.randomUUID();\r\n\r\n            await env.DB.batch([\r\n                env.DB.prepare(\"UPDATE Users SET credits_balance = credits_balance + ? WHERE id = ?\").bind(creditsToGrant, userId),\r\n                env.DB.prepare(\r\n                    \"INSERT INTO Transactions (id, user_id, type, amount, credits_granted, status, timestamp) VALUES (?, ?, ?, ?, ?, ?, ?)\"\r\n                ).bind(transactionId, userId, 'credit_purchase', 0, creditsToGrant, 'COMPLETED', timestamp)\r\n            ]);\r\n\r\n            logger.info('credits_purchased', undefined, { userId, packageId: package_id, creditsAdded: creditsToGrant });\r\n            return new Response(JSON.stringify({\r\n                success: true,\r\n                data: {\r\n                    credits_added: creditsToGrant,\r\n                    transaction_id: transactionId\r\n                }\r\n            }), { headers: jsonHeaders });\r\n        }\r\n\r\n        // 2. Subscribe (POST /v2/billing/subscribe)\r\n        if (path.endsWith('/subscribe') && request.method === 'POST') {\r\n            const body = SubscribeSchema.parse(await request.json());\r\n            const { tier, interval } = body;\r\n\r\n            const duration = interval === 'yearly' ? 365 * 24 * 60 * 60 * 1000 : 30 * 24 * 60 * 60 * 1000;\r\n            const expiresAt = Date.now() + duration;\r\n\r\n            await env.DB.prepare(\r\n                \"UPDATE Users SET subscription_tier = ?, subscription_expires_at = ? WHERE id = ?\"\r\n            ).bind(tier, expiresAt, userId).run();\r\n\r\n            logger.info('user_subscribed', undefined, { userId, tier, interval });\r\n            return new Response(JSON.stringify({\r\n                success: true,\r\n                data: {\r\n                    tier,\r\n                    expires_at: expiresAt\r\n                }\r\n            }), { headers: jsonHeaders });\r\n        }\r\n\r\n        // 3. User Billing Info (GET /v2/billing/info)\r\n        if (path.endsWith('/info') && request.method === 'GET') {\r\n            const result = await env.DB.prepare(\r\n                \"SELECT credits_balance, subscription_tier, subscription_expires_at FROM Users WHERE id = ?\"\r\n            ).bind(userId).first();\r\n\r\n            if (!result) throw new NotFoundError('User');\r\n\r\n            return new Response(JSON.stringify({ success: true, data: result }), {\r\n                headers: jsonHeaders\r\n            });\r\n        }\r\n    } catch (e: any) {\r\n        if (e instanceof z.ZodError) throw new ValidationError(e.errors[0].message);\r\n        if (e instanceof AppError) throw e;\r\n        throw new AppError('Billing operation failed', 500, 'BILLING_ERROR', e);\r\n    }\r\n\r\n    throw new AppError('Route not found', 404, 'NOT_FOUND');\r\n}\r\n\r\nexport async function handleStripeWebhook(request: Request, env: Env): Promise<Response> {\r\n    const signature = request.headers.get('stripe-signature');\r\n    const webhookSecret = (env as any).STRIPE_WEBHOOK_SECRET;\r\n\r\n    if (!signature) throw new AuthenticationError('Missing Stripe signature');\r\n    if (!webhookSecret) throw new AppError('Webhook not configured', 503, 'CONFIG_ERROR');\r\n\r\n    const body = await request.text();\r\n    const isValid = await verifyStripeSignature(body, signature, webhookSecret);\r\n\r\n    if (!isValid) throw new AuthenticationError('Invalid Stripe signature');\r\n\r\n    const event = JSON.parse(body);\r\n\r\n    const existingEvent = await env.DB.prepare(\r\n        'SELECT id FROM ProcessedWebhooks WHERE event_id = ?'\r\n    ).bind(event.id).first();\r\n\r\n    if (existingEvent) {\r\n        return new Response(JSON.stringify({ success: true, message: 'Already processed' }), {\r\n            headers: { 'Content-Type': 'application/json' }\r\n        });\r\n    }\r\n\r\n    try {\r\n        switch (event.type) {\r\n            case 'checkout.session.completed':\r\n                await handleCheckoutComplete(env, event.data.object);\r\n                break;\r\n            case 'customer.subscription.created':\r\n            case 'customer.subscription.updated':\r\n                await handleSubscriptionUpdate(env, event.data.object);\r\n                break;\r\n            case 'customer.subscription.deleted':\r\n                await handleSubscriptionCanceled(env, event.data.object);\r\n                break;\r\n            default:\r\n                logger.info('unhandled_webhook_type', undefined, { type: event.type });\r\n        }\r\n\r\n        await env.DB.prepare(\r\n            'INSERT INTO ProcessedWebhooks (event_id, event_type, processed_at) VALUES (?, ?, ?)'\r\n        ).bind(event.id, event.type, Date.now()).run();\r\n\r\n        return new Response(JSON.stringify({ success: true }), {\r\n            headers: { 'Content-Type': 'application/json' }\r\n        });\r\n    } catch (error: any) {\r\n        logger.error('stripe_webhook_error', error, { eventId: event.id });\r\n        throw error;\r\n    }\r\n}\r\n\r\nasync function verifyStripeSignature(payload: string, signature: string, secret: string): Promise<boolean> {\r\n    try {\r\n        const parts = signature.split(',').reduce((acc, part) => {\r\n            const [key, value] = part.split('=');\r\n            acc[key] = value;\r\n            return acc;\r\n        }, {} as Record<string, string>);\r\n\r\n        const timestamp = parts['t'];\r\n        const expectedSig = parts['v1'];\r\n\r\n        if (!timestamp || !expectedSig) return false;\r\n\r\n        const age = Date.now() / 1000 - parseInt(timestamp);\r\n        if (age > 300) return false;\r\n\r\n        const signedPayload = `${timestamp}.${payload}`;\r\n        const encoder = new TextEncoder();\r\n        const key = await crypto.subtle.importKey(\r\n            'raw',\r\n            encoder.encode(secret),\r\n            { name: 'HMAC', hash: 'SHA-256' },\r\n            false,\r\n            ['sign']\r\n        );\r\n\r\n        const signatureBuffer = await crypto.subtle.sign('HMAC', key, encoder.encode(signedPayload));\r\n        const computedSig = Array.from(new Uint8Array(signatureBuffer))\r\n            .map(b => b.toString(16).padStart(2, '0'))\r\n            .join('');\r\n\r\n        return computedSig === expectedSig;\r\n    } catch (e) {\r\n        return false;\r\n    }\r\n}\r\n\r\nasync function handleCheckoutComplete(env: Env, session: any) {\r\n    const userId = session.client_reference_id;\r\n    const creditsToGrant = parseInt(session.metadata?.credits || '0');\r\n\r\n    if (userId && creditsToGrant > 0) {\r\n        await env.DB.prepare('UPDATE Users SET credits_balance = credits_balance + ? WHERE id = ?').bind(creditsToGrant, userId).run();\r\n        await env.DB.prepare('INSERT INTO Transactions (id, user_id, type, amount, credits_granted, status, timestamp) VALUES (?, ?, ?, ?, ?, ?, ?)')\r\n            .bind(crypto.randomUUID(), userId, 'credit_purchase', session.amount_total / 100, creditsToGrant, 'COMPLETED', Date.now()).run();\r\n    }\r\n}\r\n\r\nasync function handleSubscriptionUpdate(env: Env, subscription: any) {\r\n    const userId = subscription.metadata?.user_id;\r\n    const tier = subscription.metadata?.tier || 'plus';\r\n    const expiresAt = subscription.current_period_end * 1000;\r\n    if (userId) {\r\n        await env.DB.prepare('UPDATE Users SET subscription_tier = ?, subscription_expires_at = ? WHERE id = ?').bind(tier, expiresAt, userId).run();\r\n    }\r\n}\r\n\r\nasync function handleSubscriptionCanceled(env: Env, subscription: any) {\r\n    const userId = subscription.metadata?.user_id;\r\n    if (userId) {\r\n        await env.DB.prepare('UPDATE Users SET subscription_tier = ?, subscription_expires_at = NULL WHERE id = ?').bind('free', userId).run();\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\boost.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1762,1765],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1762,1765],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3998,4001],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3998,4001],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":142,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4738,4741],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4738,4741],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Profile Boost System\r\n// Boost visibility in discovery feed\r\n\r\nimport { Env } from './index'\r\nimport { z } from 'zod';\r\nimport { AuthenticationError, ValidationError, AppError } from './errors';\r\nimport { logger } from './logger';\r\n\r\n// Zod Schema\r\nconst ActivateBoostSchema = z.object({\r\n    duration_minutes: z.number().int().min(1).max(240).default(30),\r\n});\r\n\r\ninterface BoostStatus {\r\n    is_active: boolean\r\n    started_at?: number\r\n    expires_at?: number\r\n    views_gained?: number\r\n}\r\n\r\nexport async function activateBoost(\r\n    env: Env,\r\n    userId: string,\r\n    durationMinutes: number = 30\r\n): Promise<{ success: boolean; data?: BoostStatus; error?: string }> {\r\n    try {\r\n        const now = Math.floor(Date.now() / 1000)\r\n        const expiresAt = now + (durationMinutes * 60)\r\n\r\n        // Check if user already has active boost\r\n        const existing = await env.DB.prepare(\r\n            'SELECT * FROM ActiveBoosts WHERE user_id = ? AND expires_at > ?'\r\n        )\r\n            .bind(userId, now)\r\n            .first()\r\n\r\n        if (existing) {\r\n            throw new AppError('You already have an active boost', 409, 'BOOST_ALREADY_ACTIVE');\r\n        }\r\n\r\n        // Activate boost\r\n        await env.DB.prepare(\r\n            'INSERT INTO ActiveBoosts (user_id, started_at, expires_at, views_gained) VALUES (?, ?, ?, ?)'\r\n        )\r\n            .bind(userId, now, expiresAt, 0)\r\n            .run()\r\n\r\n        logger.info('boost_activated', undefined, { userId, durationMinutes });\r\n        return {\r\n            success: true,\r\n            data: {\r\n                is_active: true,\r\n                started_at: now,\r\n                expires_at: expiresAt,\r\n                views_gained: 0,\r\n            },\r\n        }\r\n    } catch (error: any) {\r\n        if (error instanceof AppError) {\r\n            throw error;\r\n        }\r\n        throw new AppError('Failed to activate boost', 500, 'BOOST_ACTIVATION_FAILED', error);\r\n    }\r\n}\r\n\r\nexport async function getBoostStatus(env: Env, userId: string): Promise<BoostStatus> {\r\n    const now = Math.floor(Date.now() / 1000)\r\n\r\n    const boost = await env.DB.prepare(\r\n        'SELECT * FROM ActiveBoosts WHERE user_id = ? AND expires_at > ?'\r\n    )\r\n        .bind(userId, now)\r\n        .first()\r\n\r\n    if (!boost) {\r\n        return { is_active: false }\r\n    }\r\n\r\n    return {\r\n        is_active: true,\r\n        started_at: boost.started_at as number,\r\n        expires_at: boost.expires_at as number,\r\n        views_gained: boost.views_gained as number,\r\n    }\r\n}\r\n\r\n// Get best time to boost (peak hours)\r\nexport function getBestBoostTime(): { hour: number; reason: string } {\r\n    const now = new Date()\r\n    const hour = now.getHours()\r\n\r\n    // Peak hours: 7-9 PM on weekdays, 12-2 PM and 7-10 PM on weekends\r\n    const isWeekend = now.getDay() === 0 || now.getDay() === 6\r\n\r\n    if (isWeekend) {\r\n        if (hour >= 12 && hour <= 14) {\r\n            return { hour: 12, reason: 'Lunch time - high activity!' }\r\n        } else if (hour >= 19 && hour <= 22) {\r\n            return { hour: 19, reason: 'Evening - peak activity!' }\r\n        }\r\n    } else {\r\n        if (hour >= 19 && hour <= 21) {\r\n            return { hour: 19, reason: 'Evening - peak activity!' }\r\n        }\r\n    }\r\n\r\n    return { hour: 19, reason: 'Evening hours (7-9 PM) have the most activity' }\r\n}\r\n\r\nexport async function handleBoost(request: Request, env: Env): Promise<Response> {\r\n    const { verifyAuth } = await import('./auth');\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    try {\r\n        const userId = await verifyAuth(request, env);\r\n        if (!userId) throw new AuthenticationError();\r\n\r\n        const url = new URL(request.url);\r\n        const path = url.pathname;\r\n        const method = request.method;\r\n\r\n        if (path === '/v2/boost/activate' && method === 'POST') {\r\n            let body;\r\n            try {\r\n                body = ActivateBoostSchema.parse(await request.json());\r\n            } catch (error: any) {\r\n                throw new ValidationError('Invalid request body', error);\r\n            }\r\n            const result = await activateBoost(env, userId, body.duration_minutes);\r\n            return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n        }\r\n\r\n        if (path === '/v2/boost/status' && method === 'GET') {\r\n            const result = await getBoostStatus(env, userId);\r\n            return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n        }\r\n\r\n        return new Response(JSON.stringify({ success: false, error: 'Route not found' }), {\r\n            status: 404,\r\n            headers: jsonHeaders\r\n        });\r\n    } catch (error: any) {\r\n        logger.error('handle_boost_error', error, { path: request.url, method: request.method });\r\n        let status = 500;\r\n        let message = 'Internal Server Error';\r\n        let code = 'INTERNAL_SERVER_ERROR';\r\n\r\n        if (error instanceof AuthenticationError) {\r\n            status = 401;\r\n            message = error.message;\r\n            code = error.code;\r\n        } else if (error instanceof ValidationError) {\r\n            status = 400;\r\n            message = error.message;\r\n            code = error.code;\r\n        } else if (error instanceof AppError) {\r\n            status = error.status;\r\n            message = error.message;\r\n            code = error.code;\r\n        }\r\n\r\n        return new Response(JSON.stringify({ success: false, error: message, code: code }), {\r\n            status: status,\r\n            headers: jsonHeaders\r\n        });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\chat.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1202,1205],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1202,1205],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1216,1219],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1216,1219],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1278,1281],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1278,1281],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1292,1295],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1292,1295],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'sharedGoals' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":41,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":41,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2586,2589],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2586,2589],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3073,3076],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3073,3076],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":87,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3859,3862],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3859,3862],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Chat Module - AI Innovation\r\n * Handles AI Icebreakers and Chat Insights\r\n */\r\nimport { Env } from './index';\r\nimport { verifyAuth } from './auth';\r\nimport { AuthenticationError, ValidationError, NotFoundError, AppError } from './errors';\r\nimport { logger } from './logger';\r\n\r\nexport async function handleChatAI(request: Request, env: Env): Promise<Response> {\r\n    const userId = await verifyAuth(request, env);\r\n    if (!userId) throw new AuthenticationError();\r\n\r\n    const url = new URL(request.url);\r\n    const path = url.pathname;\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    try {\r\n        // 1. Generate Icebreakers (GET /v2/chat/icebreakers?with_user_id=...)\r\n        if (path === '/v2/chat/icebreakers' && request.method === 'GET') {\r\n            const withUserId = url.searchParams.get('with_user_id');\r\n            if (!withUserId) throw new ValidationError(\"Missing with_user_id\");\r\n\r\n            // Fetch Both Users\r\n            const { results } = await env.DB.prepare(\r\n                \"SELECT id, name, interests, relationship_goals FROM Users WHERE id IN (?, ?)\"\r\n            ).bind(userId, withUserId).all();\r\n\r\n            const u1 = (results as any).find((r: any) => r.id === userId);\r\n            const u2 = (results as any).find((r: any) => r.id === withUserId);\r\n\r\n            if (!u1 || !u2) throw new NotFoundError(\"Users\");\r\n\r\n            // Analyze overlap\r\n            const int1 = JSON.parse(u1.interests || '[]');\r\n            const int2 = JSON.parse(u2.interests || '[]');\r\n            const sharedInterests = int1.filter((i: string) => int2.includes(i));\r\n\r\n            const goals1 = JSON.parse(u1.relationship_goals || '[]');\r\n            const goals2 = JSON.parse(u2.relationship_goals || '[]');\r\n            const sharedGoals = goals1.filter((g: string) => goals2.includes(g));\r\n\r\n            const prompt = `\r\n                You are a charming dating assistant for the app \"Love Vibes\".\r\n                Generate 3 short, engaging, and personalized icebreakers for User A to send to User B.\r\n                User A Interests: ${u1.interests}\r\n                User B Interests: ${u2.interests}\r\n                Shared Goals: ${u1.relationship_goals} and ${u2.relationship_goals}\r\n                Guidelines:\r\n                1. Keep them under 15 words each.\r\n                2. High focus on shared interests: ${sharedInterests.join(', ')}.\r\n                3. Output ONLY a valid JSON array of strings.\r\n            `;\r\n\r\n            let icebreakers = [];\r\n            try {\r\n                const aiResponse: any = await env.AI.run('@cf/meta/llama-3.1-8b-instruct', {\r\n                    messages: [{ role: 'user', content: prompt }]\r\n                });\r\n\r\n                const text = aiResponse.response || \"\";\r\n                const jsonMatch = text.match(/\\[.*\\]/s);\r\n                if (jsonMatch) {\r\n                    icebreakers = JSON.parse(jsonMatch[0]);\r\n                } else {\r\n                    icebreakers = [text.split('\\n')[0]];\r\n                }\r\n            } catch (e: any) {\r\n                logger.error(\"AI Icebreaker failed\", e, { userId, withUserId });\r\n                // Fallback to basic logic if AI fails\r\n                icebreakers = [\r\n                    `Hey! I notice we both love ${sharedInterests[0] || 'exploring'}.`,\r\n                    \"What's the most underrated spot in our city?\",\r\n                    \"Tell me one thing that's NOT on your profile!\"\r\n                ];\r\n            }\r\n\r\n            logger.info('icebreakers_generated', undefined, { userId, withUserId });\r\n\r\n            return new Response(JSON.stringify({\r\n                success: true,\r\n                data: {\r\n                    icebreakers: icebreakers.slice(0, 3)\r\n                }\r\n            }), { headers: jsonHeaders });\r\n        }\r\n    } catch (e: any) {\r\n        if (e instanceof AppError) throw e;\r\n        throw new AppError('Chat AI operation failed', 500, 'CHAT_AI_ERROR', e);\r\n    }\r\n\r\n    throw new NotFoundError(\"Chat route\");\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\chemistry.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1699,1702],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1699,1702],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3175,3178],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3175,3178],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":144,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":144,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4965,4968],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4965,4968],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":194,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":194,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7396,7399],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7396,7399],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Biometric Chemistry Test\r\n// Heart rate synchrony detection during video calls using PPG\r\n\r\nimport { Env } from './index'\r\nimport { z } from 'zod';\r\nimport { ValidationError, AuthenticationError, AppError, NotFoundError } from './errors';\r\nimport { logger } from './logger';\r\nimport { verifyAuth } from './auth';\r\n\r\nexport interface HeartRateData {\r\n    timestamp: number\r\n    bpm: number\r\n}\r\n\r\nexport interface ChemistryResult {\r\n    test_id: string\r\n    user_a_avg_hr: number\r\n    user_b_avg_hr: number\r\n    sync_score: number\r\n    chemistry_detected: boolean\r\n    message: string\r\n}\r\n\r\nconst StartTestSchema = z.object({\r\n    match_id: z.string().uuid(),\r\n    target_id: z.string().uuid(),\r\n});\r\n\r\nconst HeartRateDataSchema = z.object({\r\n    timestamp: z.number(),\r\n    bpm: z.number().min(30).max(220),\r\n});\r\n\r\nconst SubmitDataSchema = z.object({\r\n    test_id: z.string().uuid(),\r\n    heart_rate_data: z.array(HeartRateDataSchema).min(1),\r\n});\r\n\r\n// POST /api/chemistry/start-test - Initialize chemistry test\r\nexport async function startChemistryTest(\r\n    env: Env,\r\n    matchId: string,\r\n    userAId: string,\r\n    userBId: string\r\n): Promise<{ success: boolean; test_id: string }> {\r\n    const testId = crypto.randomUUID()\r\n    const now = Math.floor(Date.now() / 1000)\r\n\r\n    try {\r\n        await env.DB.prepare(\r\n            'INSERT INTO ChemistryTests (id, match_id, user_a_id, user_b_id, created_at) VALUES (?, ?, ?, ?, ?)'\r\n        )\r\n            .bind(testId, matchId, userAId, userBId, now)\r\n            .run()\r\n\r\n        logger.info('chemistry_test_started', undefined, { testId, matchId, userAId, userBId });\r\n        return { success: true, test_id: testId }\r\n    } catch (error: any) {\r\n        throw new AppError('Failed to start chemistry test', 500, 'START_TEST_ERROR', error);\r\n    }\r\n}\r\n\r\n// POST /api/chemistry/submit-data - Submit heart rate data\r\nexport async function submitChemistryData(\r\n    env: Env,\r\n    testId: string,\r\n    userId: string,\r\n    heartRateData: HeartRateData[]\r\n): Promise<{ success: boolean }> {\r\n    try {\r\n        const bpms = heartRateData.map((d) => d.bpm)\r\n        const avgHr = bpms.reduce((a, b) => a + b, 0) / bpms.length\r\n        const variance = calculateVariance(bpms)\r\n\r\n        const test = await env.DB.prepare('SELECT user_a_id, user_b_id FROM ChemistryTests WHERE id = ?')\r\n            .bind(testId)\r\n            .first()\r\n\r\n        if (!test) throw new NotFoundError('Chemistry Test');\r\n\r\n        const isUserA = test.user_a_id === userId\r\n\r\n        if (isUserA) {\r\n            await env.DB.prepare(\r\n                'UPDATE ChemistryTests SET user_a_hr_avg = ?, user_a_hr_variance = ? WHERE id = ?'\r\n            )\r\n                .bind(Math.round(avgHr), variance, testId)\r\n                .run()\r\n        } else {\r\n            await env.DB.prepare(\r\n                'UPDATE ChemistryTests SET user_b_hr_avg = ?, user_b_hr_variance = ? WHERE id = ?'\r\n            )\r\n                .bind(Math.round(avgHr), variance, testId)\r\n                .run()\r\n        }\r\n\r\n        logger.info('chemistry_data_submitted', undefined, { testId, userId, avgHr });\r\n        return { success: true }\r\n    } catch (error: any) {\r\n        if (error instanceof AppError) throw error;\r\n        throw new AppError('Failed to submit chemistry data', 500, 'SUBMIT_DATA_ERROR', error);\r\n    }\r\n}\r\n\r\n// GET /api/chemistry/results/:testId - Get chemistry test results\r\nexport async function getChemistryResults(env: Env, testId: string): Promise<ChemistryResult | null> {\r\n    try {\r\n        const test = await env.DB.prepare('SELECT * FROM ChemistryTests WHERE id = ?')\r\n            .bind(testId)\r\n            .first()\r\n\r\n        if (!test) throw new NotFoundError('Chemistry Test');\r\n\r\n        if (!test.user_a_hr_avg || !test.user_b_hr_avg) {\r\n            return null // Test not complete\r\n        }\r\n\r\n        const syncScore = calculateSynchronyScore(\r\n            test.user_a_hr_avg as number,\r\n            test.user_b_hr_avg as number,\r\n            test.user_a_hr_variance as number,\r\n            test.user_b_hr_variance as number\r\n        )\r\n\r\n        const chemistryDetected = syncScore >= 70\r\n        await env.DB.prepare(\r\n            'UPDATE ChemistryTests SET sync_score = ?, chemistry_detected = ?, test_duration = ? WHERE id = ?'\r\n        )\r\n            .bind(syncScore, chemistryDetected, 60, testId)\r\n            .run()\r\n\r\n        logger.info('chemistry_results_generated', undefined, { testId, syncScore, detected: chemistryDetected });\r\n\r\n        return {\r\n            test_id: testId,\r\n            user_a_avg_hr: test.user_a_hr_avg as number,\r\n            user_b_avg_hr: test.user_b_hr_avg as number,\r\n            sync_score: syncScore,\r\n            chemistry_detected: chemistryDetected,\r\n            message: chemistryDetected\r\n                ? ' Chemistry Detected! Your heart rates elevated and synced!'\r\n                : ' Keep getting to know each other!',\r\n        }\r\n    } catch (error: any) {\r\n        if (error instanceof AppError) throw error;\r\n        throw new AppError('Failed to get chemistry results', 500, 'GET_RESULTS_ERROR', error);\r\n    }\r\n}\r\n\r\nfunction calculateVariance(values: number[]): number {\r\n    const mean = values.reduce((a, b) => a + b, 0) / values.length\r\n    const squaredDiffs = values.map((v) => Math.pow(v - mean, 2))\r\n    return squaredDiffs.reduce((a, b) => a + b, 0) / values.length\r\n}\r\n\r\nfunction calculateSynchronyScore(hrA: number, hrB: number, varA: number, varB: number): number {\r\n    const hrDiff = Math.abs(hrA - hrB)\r\n    const hrSimilarity = Math.max(0, 100 - hrDiff * 2)\r\n    const varDiff = Math.abs(varA - varB)\r\n    const varSimilarity = Math.max(0, 100 - varDiff * 5)\r\n    const elevationBonus = hrA > 75 && hrB > 75 ? 20 : 0\r\n    const score = (hrSimilarity * 0.5 + varSimilarity * 0.3 + elevationBonus) * 1.2\r\n    return Math.min(100, Math.round(score))\r\n}\r\n\r\nexport async function handleChemistry(request: Request, env: Env): Promise<Response> {\r\n    const userId = await verifyAuth(request, env);\r\n    if (!userId) throw new AuthenticationError();\r\n\r\n    const url = new URL(request.url);\r\n    const path = url.pathname;\r\n    const method = request.method;\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    try {\r\n        if (path === '/v2/chemistry/start' && method === 'POST') {\r\n            const body = StartTestSchema.parse(await request.json());\r\n            const result = await startChemistryTest(env, body.match_id, userId, body.target_id);\r\n            return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n        }\r\n\r\n        if (path === '/v2/chemistry/submit' && method === 'POST') {\r\n            const body = SubmitDataSchema.parse(await request.json());\r\n            const result = await submitChemistryData(env, body.test_id, userId, body.heart_rate_data);\r\n            return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n        }\r\n\r\n        if (path.startsWith('/v2/chemistry/results/') && method === 'GET') {\r\n            const testId = path.split('/').pop();\r\n            if (!testId) throw new ValidationError(\"Missing test ID\");\r\n            const result = await getChemistryResults(env, testId);\r\n            return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n        }\r\n    } catch (e: any) {\r\n        if (e instanceof z.ZodError) throw new ValidationError(e.errors[0].message);\r\n        throw e;\r\n    }\r\n\r\n    throw new NotFoundError(\"Chemistry route\");\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\durable_objects.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[810,813],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[810,813],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1235,1238],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1235,1238],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'err' is defined but never used. Allowed unused caught errors must match /^_/u.","line":91,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":91,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'err' is defined but never used. Allowed unused caught errors must match /^_/u.","line":181,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":181,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":195,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6810,6813],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6810,6813],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":231,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":231,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8031,8034],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8031,8034],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'err' is defined but never used. Allowed unused caught errors must match /^_/u.","line":247,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":247,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'err' is defined but never used. Allowed unused caught errors must match /^_/u.","line":268,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":268,"endColumn":21}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Durable Objects: ChatRoom\r\n * Handles Real-time WebSocket Messaging for a Match\r\n */\r\nimport { Env } from './index';\r\nimport { logger } from './logger';\r\n\r\ninterface ChatMessage {\r\n    id: string;\r\n    sender_id: string;\r\n    text: string;\r\n    type: string;\r\n    timestamp: number;\r\n}\r\n\r\nexport class ChatRoom {\r\n    state: DurableObjectState;\r\n    sessions: Map<WebSocket, string>; // WebSocket -> userId\r\n    env: Env;\r\n    lastActive: number;\r\n    matchId: string | null;\r\n\r\n    constructor(state: DurableObjectState, env: Env) {\r\n        this.state = state;\r\n        this.env = env;\r\n        this.sessions = new Map();\r\n        this.lastActive = Date.now();\r\n        this.matchId = null;\r\n\r\n        // Auto-hibernate after 5 minutes of inactivity (increased from 30s)\r\n        void (this.state as any).setAlarm(Date.now() + 5 * 60 * 1000);\r\n    }\r\n\r\n    async alarm() {\r\n        // Only hibernate if no active sessions\r\n        if (this.sessions.size === 0 && Date.now() - this.lastActive >= 5 * 60 * 1000) {\r\n            // Clean up and hibernate\r\n            logger.info('chat_room_hibernating', undefined, { matchId: this.matchId });\r\n        } else {\r\n            // Check again later\r\n            void (this.state as any).setAlarm(Date.now() + 60 * 1000);\r\n        }\r\n    }\r\n\r\n    async fetch(request: Request) {\r\n        const url = new URL(request.url);\r\n\r\n        // Handle non-WebSocket requests (e.g., loading history)\r\n        if (request.method === 'GET' && url.pathname.endsWith('/history')) {\r\n            return this.getHistory(url);\r\n        }\r\n\r\n        const upgradeHeader = request.headers.get('Upgrade');\r\n        if (!upgradeHeader || upgradeHeader !== 'websocket') {\r\n            return new Response('Expected Upgrade: websocket', { status: 426 });\r\n        }\r\n\r\n        const userId = url.searchParams.get('user_id');\r\n        this.matchId = url.searchParams.get('match_id') || this.matchId;\r\n\r\n        const pair = new WebSocketPair();\r\n        const [client, server] = Object.values(pair);\r\n\r\n        await this.handleSession(server, userId);\r\n\r\n        return new Response(null, {\r\n            status: 101,\r\n            webSocket: client,\r\n        });\r\n    }\r\n\r\n    async getHistory(url: URL): Promise<Response> {\r\n        const limit = parseInt(url.searchParams.get('limit') || '50');\r\n\r\n        try {\r\n            // Get messages from Durable Object storage\r\n            const messages: ChatMessage[] = [];\r\n            const stored = await this.state.storage.list<ChatMessage>({ prefix: 'msg_' });\r\n\r\n            for (const [, value] of stored) {\r\n                messages.push(value);\r\n            }\r\n\r\n            // Sort by timestamp and limit\r\n            messages.sort((a, b) => a.timestamp - b.timestamp);\r\n            const limited = messages.slice(-limit);\r\n\r\n            return new Response(JSON.stringify({ success: true, messages: limited }), {\r\n                headers: { 'Content-Type': 'application/json' }\r\n            });\r\n        } catch (err) {\r\n            return new Response(JSON.stringify({ success: false, error: 'Failed to load history' }), {\r\n                status: 500,\r\n                headers: { 'Content-Type': 'application/json' }\r\n            });\r\n        }\r\n    }\r\n\r\n    async handleSession(webSocket: WebSocket, userId: string | null) {\r\n        webSocket.accept();\r\n        this.sessions.set(webSocket, userId || 'anonymous');\r\n        this.lastActive = Date.now();\r\n\r\n        // Send connection confirmation\r\n        webSocket.send(JSON.stringify({\r\n            type: 'connected',\r\n            user_count: this.sessions.size,\r\n            timestamp: Date.now()\r\n        }));\r\n\r\n        webSocket.addEventListener('message', async (event: MessageEvent) => {\r\n            try {\r\n                this.lastActive = Date.now();\r\n                const data = JSON.parse(event.data as string);\r\n\r\n                // Create message object\r\n                const messageId = crypto.randomUUID();\r\n                const message: ChatMessage = {\r\n                    id: messageId,\r\n                    sender_id: userId || 'anonymous',\r\n                    text: data.text,\r\n                    timestamp: Date.now(),\r\n                    type: data.type || 'text' // 'text', 'gift', 'image'\r\n                };\r\n\r\n                const msgString = JSON.stringify(message);\r\n\r\n                // 1. Broadcast Real-time to all sessions\r\n                for (const [session] of this.sessions) {\r\n                    if (session.readyState === WebSocket.OPEN) {\r\n                        session.send(msgString);\r\n                    }\r\n                }\r\n\r\n                // 2. Persist to Durable Object storage (async, non-blocking)\r\n                void this.persistMessage(message);\r\n\r\n                // 3. Also persist to D1 for long-term storage (async, non-blocking)\r\n                if (this.matchId) {\r\n                    void this.persistToDatabase(message);\r\n                }\r\n\r\n            } catch (err) {\r\n                logger.error('chat_message_error', err, { matchId: this.matchId });\r\n            }\r\n        });\r\n\r\n        webSocket.addEventListener('close', () => {\r\n            this.sessions.delete(webSocket);\r\n\r\n            // Notify other users\r\n            const notification = JSON.stringify({\r\n                type: 'user_left',\r\n                user_count: this.sessions.size,\r\n                timestamp: Date.now()\r\n            });\r\n\r\n            for (const [session] of this.sessions) {\r\n                if (session.readyState === WebSocket.OPEN) {\r\n                    session.send(notification);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    async persistMessage(message: ChatMessage) {\r\n        try {\r\n            await this.state.storage.put(`msg_${message.timestamp}_${message.id}`, message);\r\n        } catch (err) {\r\n            logger.error('message_persist_error', err, { messageId: message.id });\r\n        }\r\n    }\r\n\r\n    async persistToDatabase(message: ChatMessage) {\r\n        try {\r\n            await this.env.DB.prepare(\r\n                'INSERT INTO ChatMessages (id, match_id, sender_id, message_text, message_type, created_at) VALUES (?, ?, ?, ?, ?, ?)'\r\n            )\r\n                .bind(message.id, this.matchId, message.sender_id, message.text, message.type, message.timestamp)\r\n                .run();\r\n        } catch (err) {\r\n            // Silent fail for database persistence - DO storage is primary\r\n            logger.warn('chat_db_persist_failed', 'Failed to persist message to D1', { messageId: message.id });\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Durable Objects: MatchLobby\r\n * Handles waiting room and matchmaking coordination\r\n */\r\nexport class MatchLobby {\r\n    state: DurableObjectState;\r\n    env: Env;\r\n    waitingUsers: Map<string, { userId: string; preferences: any; joinedAt: number }>;\r\n\r\n    constructor(state: DurableObjectState, env: Env) {\r\n        this.state = state;\r\n        this.env = env;\r\n        this.waitingUsers = new Map();\r\n    }\r\n\r\n    async fetch(request: Request) {\r\n        const url = new URL(request.url);\r\n        const method = request.method;\r\n\r\n        if (method === 'POST' && url.pathname.endsWith('/join')) {\r\n            return this.joinLobby(request);\r\n        }\r\n\r\n        if (method === 'POST' && url.pathname.endsWith('/leave')) {\r\n            return this.leaveLobby(request);\r\n        }\r\n\r\n        if (method === 'GET' && url.pathname.endsWith('/status')) {\r\n            return new Response(JSON.stringify({\r\n                success: true,\r\n                waiting_count: this.waitingUsers.size\r\n            }), {\r\n                headers: { 'Content-Type': 'application/json' }\r\n            });\r\n        }\r\n\r\n        return new Response(JSON.stringify({ success: true, message: 'Match Lobby Active' }), {\r\n            headers: { 'Content-Type': 'application/json' }\r\n        });\r\n    }\r\n\r\n    async joinLobby(request: Request): Promise<Response> {\r\n        try {\r\n            const body = await request.json() as { user_id: string; preferences?: any };\r\n            const { user_id, preferences } = body;\r\n\r\n            this.waitingUsers.set(user_id, {\r\n                userId: user_id,\r\n                preferences: preferences || {},\r\n                joinedAt: Date.now()\r\n            });\r\n\r\n            return new Response(JSON.stringify({\r\n                success: true,\r\n                position: this.waitingUsers.size,\r\n                message: 'Joined match lobby'\r\n            }), {\r\n                headers: { 'Content-Type': 'application/json' }\r\n            });\r\n        } catch (err) {\r\n            return new Response(JSON.stringify({ success: false, error: 'Invalid request' }), {\r\n                status: 400,\r\n                headers: { 'Content-Type': 'application/json' }\r\n            });\r\n        }\r\n    }\r\n\r\n    async leaveLobby(request: Request): Promise<Response> {\r\n        try {\r\n            const body = await request.json() as { user_id: string };\r\n            const { user_id } = body;\r\n\r\n            this.waitingUsers.delete(user_id);\r\n\r\n            return new Response(JSON.stringify({\r\n                success: true,\r\n                message: 'Left match lobby'\r\n            }), {\r\n                headers: { 'Content-Type': 'application/json' }\r\n            });\r\n        } catch (err) {\r\n            return new Response(JSON.stringify({ success: false, error: 'Invalid request' }), {\r\n                status: 400,\r\n                headers: { 'Content-Type': 'application/json' }\r\n            });\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\errors.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":6,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[199,202],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[199,202],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[611,614],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[611,614],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1127,1130],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1127,1130],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1233,1236],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1233,1236],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export class AppError extends Error {\r\n    constructor(\r\n        public message: string,\r\n        public status: number = 500,\r\n        public code: string = 'INTERNAL_ERROR',\r\n        public data?: any\r\n    ) {\r\n        super(message);\r\n        this.name = this.constructor.name;\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            success: false,\r\n            error: {\r\n                message: this.message,\r\n                code: this.code,\r\n                data: this.data\r\n            }\r\n        };\r\n    }\r\n}\r\n\r\nexport class ValidationError extends AppError {\r\n    constructor(message: string, data?: any) {\r\n        super(message, 400, 'VALIDATION_ERROR', data);\r\n    }\r\n}\r\n\r\nexport class AuthenticationError extends AppError {\r\n    constructor(message: string = 'Unauthorized') {\r\n        super(message, 401, 'AUTH_ERROR');\r\n    }\r\n}\r\n\r\nexport class NotFoundError extends AppError {\r\n    constructor(resource: string = 'Resource') {\r\n        super(`${resource} not found`, 404, 'NOT_FOUND');\r\n    }\r\n}\r\n\r\nexport class ServerError extends AppError {\r\n    constructor(message: string = 'Everything is broken', data?: any) {\r\n        super(message, 500, 'SERVER_ERROR', data);\r\n    }\r\n}\r\n\r\nexport function handleApiError(e: any): Response {\r\n    if (e instanceof AppError) {\r\n        return new Response(JSON.stringify(e.toJSON()), {\r\n            status: e.status,\r\n            headers: { 'Content-Type': 'application/json' }\r\n        });\r\n    }\r\n\r\n    // Default 500 for unexpected errors\r\n    return new Response(JSON.stringify({\r\n        success: false,\r\n        error: {\r\n            message: 'An unexpected error occurred',\r\n            code: 'INTERNAL_ERROR'\r\n        }\r\n    }), {\r\n        status: 500,\r\n        headers: { 'Content-Type': 'application/json' }\r\n    });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\feed.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1007,1010],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1007,1010],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1016,1019],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1016,1019],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2701,2704],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2701,2704],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4097,4100],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4097,4100],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":121,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4635,4638],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4635,4638],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":145,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5777,5780],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5777,5780],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":170,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":170,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6727,6730],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6727,6730],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Feed Module (Recommendations)\r\n * Handles Geosharding and Mode Filtering (Dating vs Friendship)\r\n */\r\nimport { Env } from './index';\r\nimport { verifyAuth } from './auth';\r\n// @ts-expect-error - S2 library lacks types\r\nimport { S2 } from 's2-geometry';\r\nimport { AuthenticationError, NotFoundError, AppError, ValidationError } from './errors';\r\nimport { logger } from './logger';\r\nimport { z } from 'zod';\r\n\r\n// Zod Schema\r\nconst FeedRequestSchema = z.object({\r\n    lat: z.coerce.number().min(-90).max(90).optional(),\r\n    long: z.coerce.number().min(-180).max(180).optional(),\r\n    radius: z.coerce.number().min(1).max(500).default(50),\r\n});\r\n\r\n// Production Ready S2 Logic\r\nfunction latLonToCellId(lat: number, lon: number, level: number = 12): string {\r\n    const key = S2.latLngToKey(lat, lon, level);\r\n    return S2.keyToId(key);\r\n}\r\n\r\nfunction getNeighboringCells(cellId: string): string[] {\r\n    const _key = S2.idToKey(cellId);\r\n    return [cellId];\r\n}\r\n\r\nfunction calculateCompatibility(u1: any, u2: any): number {\r\n    let score = 0;\r\n\r\n    // 1. Relationship Goals (40%)\r\n    try {\r\n        const goals1 = JSON.parse(u1.relationship_goals || '[]');\r\n        const goals2 = JSON.parse(u2.relationship_goals || '[]');\r\n        const intersection = goals1.filter((g: string) => goals2.includes(g));\r\n        if (intersection.length > 0) score += 40;\r\n        else if (goals1.length > 0 && goals2.length > 0) score += 15; // Partial credit for having any goals set\r\n    } catch (e) {\r\n        logger.error('feed_json_parse_relationship_goals_error', 'Failed to parse relationship goals', { error: e });\r\n    }\r\n\r\n    // 2. Interests overlap (30%)\r\n    try {\r\n        const int1 = JSON.parse(u1.interests || '[]');\r\n        const int2 = JSON.parse(u2.interests || '[]');\r\n        const overlap = int1.filter((i: string) => int2.includes(i));\r\n        const overlapRatio = int1.length > 0 ? overlap.length / Math.max(int1.length, int2.length) : 0;\r\n        score += Math.min(30, overlapRatio * 60); // Aggressive overlap bonus\r\n    } catch (e) {\r\n        logger.error('feed_json_parse_interests_error', 'Failed to parse interests', { error: e });\r\n    }\r\n\r\n    // 3. Lifestyle Compatibility (20%)\r\n    if (u1.drinking === u2.drinking) score += 10;\r\n    if (u1.smoking === u2.smoking) score += 10;\r\n\r\n    // 4. Base & Random Polish (10%)\r\n    score += 5; // Base compatibility\r\n    score += Math.floor(Math.random() * 5); // Micro-variance for \"organic\" feel\r\n\r\n    return Math.min(100, Math.max(60, Math.floor(score))); // Keep it positive (60-100%)\r\n}\r\n\r\nasync function calculateSemanticScore(env: Env, text1: string, text2: string): Promise<number> {\r\n    try {\r\n        const response: any = await env.AI.run('@cf/baai/bge-base-en-v1.5', {\r\n            text: [text1, text2]\r\n        });\r\n        const [v1, v2] = response.data;\r\n\r\n        // Cosine Similarity\r\n        let dotProduct = 0;\r\n        let mag1 = 0;\r\n        let mag2 = 0;\r\n        for (let i = 0; i < v1.length; i++) {\r\n            dotProduct += v1[i] * v2[i];\r\n            mag1 += v1[i] * v1[i];\r\n            mag2 += v2[i] * v2[i];\r\n        }\r\n        const similarity = dotProduct / (Math.sqrt(mag1) * Math.sqrt(mag2));\r\n        return Math.floor(similarity * 100);\r\n    } catch (_e) {\r\n        return 70; // Default sibling \"vibe\" if AI fails\r\n    }\r\n}\r\n\r\nexport async function handleFeed(request: Request, env: Env): Promise<Response> {\r\n    const userId = await verifyAuth(request, env);\r\n    if (!userId) throw new AuthenticationError();\r\n\r\n    const url = new URL(request.url);\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    try {\r\n        const queryParams = FeedRequestSchema.parse({\r\n            lat: url.searchParams.get('lat'),\r\n            long: url.searchParams.get('long'),\r\n            radius: url.searchParams.get('radius')\r\n        });\r\n\r\n        // Get current user's profile to know their preferences\r\n        const { results: userResults } = await env.DB.prepare(\r\n            \"SELECT * FROM Users WHERE id = ?\"\r\n        ).bind(userId).all();\r\n\r\n        const currentUser: any = userResults[0];\r\n        if (!currentUser) throw new NotFoundError('User');\r\n\r\n        const lat = queryParams.lat || currentUser.lat || 0;\r\n        const long = queryParams.long || currentUser.long || 0;\r\n\r\n        // 1. Calculate Neighbors (Geosharding)\r\n        const currentCell = latLonToCellId(lat, long);\r\n        const cellsToQuery = getNeighboringCells(currentCell);\r\n\r\n        // 2. Fetch User Discovery Metadata (Cache Key)\r\n        const cacheKey = `feed_cache:${currentCell}:${currentUser.mode}`;\r\n        let feedRaw: any[] = [];\r\n\r\n        // 3. Try KV Cache first\r\n        const cachedData = await env.GEO_KV.get(cacheKey);\r\n        if (cachedData) {\r\n            feedRaw = JSON.parse(cachedData);\r\n        } else {\r\n            // 4. Cache Miss - Query D1\r\n            const { results } = await env.DB.prepare(\r\n                \"SELECT id, name, age, bio, photo_urls, s2_cell_id, mode, trust_score, location, relationship_goals, interests, height, drinking, smoking, exercise_frequency, diet, pets, star_sign \" +\r\n                \"FROM Users \" +\r\n                \"WHERE s2_cell_id IN (\" + cellsToQuery.map(() => '?').join(',') + \") \" +\r\n                \"AND mode = ? \" +\r\n                \"AND id != ? \" +\r\n                \"LIMIT 100\" // Fetch more to allow for filtering\r\n            ).bind(...cellsToQuery, currentUser.mode, userId).all();\r\n\r\n            feedRaw = results;\r\n\r\n            // Save to KV for 10 minutes\r\n            await env.GEO_KV.put(cacheKey, JSON.stringify(feedRaw), { expirationTtl: 600 });\r\n        }\r\n\r\n        // 5. Semantic Enhancement (Async Parallel)\r\n        const feed = await Promise.all(feedRaw.slice(0, 20).map(async (user: any) => {\r\n            const baseScore = calculateCompatibility(currentUser, user);\r\n            const semanticScore = await calculateSemanticScore(env, currentUser.bio || \"\", user.bio || \"\");\r\n\r\n            return {\r\n                ...user,\r\n                compatibility_score: Math.floor((baseScore * 0.7) + (semanticScore * 0.3)),\r\n                match_reason: semanticScore > 80 ? \"Deep personality match\" : \"Shared interests\"\r\n            };\r\n        }));\r\n\r\n        logger.info('feed_generated', undefined, {\r\n            userId,\r\n            cellCount: cellsToQuery.length,\r\n            source: cachedData ? 'cache' : 'db',\r\n            resultsCount: feed.length\r\n        });\r\n\r\n        return new Response(JSON.stringify({\r\n            success: true,\r\n            data: {\r\n                results: feed,\r\n                meta: { source: cachedData ? 'cache' : 'db' }\r\n            }\r\n        }), { headers: jsonHeaders });\r\n    } catch (e: any) {\r\n        if (e instanceof z.ZodError) throw new ValidationError(e.errors[0].message);\r\n        if (e instanceof AppError) throw e;\r\n        throw new AppError('Feed generation failed', 500, 'FEED_ERROR', e);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\gifting.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ValidationError' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":25,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ValidationError"},"fix":{"range":[177,193],"text":""},"desc":"Remove unused variable \"ValidationError\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1333,1336],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1333,1336],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2619,2622],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2619,2622],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Gifting Module\r\n * Handles Sending Virtual/Physical Gifts\r\n */\r\nimport { Env } from './index';\r\nimport { verifyAuth } from './auth';\r\nimport { z } from 'zod';\r\nimport { ValidationError, AuthenticationError, AppError } from './errors';\r\nimport { logger } from './logger';\r\n\r\n// Zod Schema\r\nconst GiftSchema = z.object({\r\n    recipient_id: z.string().uuid(),\r\n    gift_item_id: z.string().min(1),\r\n    message: z.string().max(200).optional(),\r\n});\r\n\r\nexport async function handleGifting(request: Request, env: Env): Promise<Response> {\r\n    const userId = await verifyAuth(request, env);\r\n    if (!userId) throw new AuthenticationError();\r\n\r\n    const body = GiftSchema.parse(await request.json());\r\n    const { recipient_id, gift_item_id, message } = body;\r\n\r\n    // 1. Determine Gift Cost based on Tiered Architecture\r\n    const giftLibrary: Record<string, number> = {\r\n        'coffee': 10,\r\n        'rose': 15,\r\n        'song': 20,\r\n        'dessert': 30,\r\n        'bouquet': 40,\r\n        'mystery': 50,\r\n        'star': 75,\r\n        'concert': 100,\r\n        'experience': 150\r\n    };\r\n\r\n    const giftCost = giftLibrary[gift_item_id] || 50;\r\n\r\n    // 2. Validate Balance\r\n    const { results } = await env.DB.prepare(\r\n        \"SELECT credits_balance FROM Users WHERE id = ?\"\r\n    ).bind(userId).all();\r\n\r\n    const user: any = results[0];\r\n\r\n    if (!user || user.credits_balance < giftCost) {\r\n        throw new AppError(\"Insufficient credits\", 402, 'INSUFFICIENT_CREDITS', {\r\n            required: giftCost,\r\n            balance: user?.credits_balance || 0\r\n        });\r\n    }\r\n\r\n    // 3. Atomic Transaction (D1)\r\n    const giftId = crypto.randomUUID();\r\n    const timestamp = Date.now();\r\n\r\n    try {\r\n        await env.DB.batch([\r\n            env.DB.prepare(\"UPDATE Users SET credits_balance = credits_balance - ? WHERE id = ?\").bind(giftCost, userId),\r\n            env.DB.prepare(\r\n                \"INSERT INTO Gifts (id, sender_id, recipient_id, item_id, message, status, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)\"\r\n            ).bind(giftId, userId, recipient_id, gift_item_id, message, 'SENT', timestamp)\r\n        ]);\r\n\r\n        const remainingCredits = user.credits_balance - giftCost;\r\n        logger.info('gift_sent', undefined, { userId, recipientId: recipient_id, giftItemId: gift_item_id, cost: giftCost });\r\n\r\n        return new Response(JSON.stringify({\r\n            success: true,\r\n            data: {\r\n                remaining_credits: remainingCredits,\r\n                gift_id: giftId\r\n            }\r\n        }), { headers: { 'Content-Type': 'application/json' } });\r\n\r\n    } catch (e: any) {\r\n        throw new AppError('Gifting failed', 500, 'GIFT_ERROR', e);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\index.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'env' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":13,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"env"},"fix":{"range":[9,13],"text":""},"desc":"Remove unused variable \"env\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[352,355],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[352,355],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { env, SELF } from 'cloudflare:test';\r\nimport { it, expect, describe } from 'vitest';\r\n\r\ndescribe('Love Vibes Backend', () => {\r\n    it('responds with health status', async () => {\r\n        const response = await SELF.fetch('http://localhost/health');\r\n        expect(response.status).toBe(200);\r\n\r\n        const data = await response.json() as any;\r\n        expect(data.status).toBe('ok');\r\n        expect(data.subsystems).toBeDefined();\r\n    });\r\n\r\n    it('returns 404 for unknown routes', async () => {\r\n        const response = await SELF.fetch('http://localhost/unknown-route');\r\n        expect(response.status).toBe(404);\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ServerError' is defined but never used. Allowed unused vars must match /^_/u.","line":29,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":47,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ServerError"},"fix":{"range":[1277,1290],"text":""},"desc":"Remove unused variable \"ServerError\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1617,1620],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1617,1620],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1995,1998],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1995,1998],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2484,2487],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2484,2487],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ctx' is defined but never used. Allowed unused args must match /^_/u.","line":74,"column":45,"nodeType":"Identifier","messageId":"unusedVar","endLine":74,"endColumn":48},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":117,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4470,4473],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4470,4473],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":167,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":167,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":176,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":176,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":291,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":291,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10508,10511],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10508,10511],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":317,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":317,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11644,11647],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11644,11647],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Love Vibes Backend - Main Entry Point\r\n */\r\n\r\nimport { handleAuth } from './auth';\r\nimport { handleFeed } from './feed';\r\nimport { handleSwipe } from './swipe';\r\nimport { handleUserUpdate } from './user';\r\nimport { handleGifting } from './gifting';\r\nimport { handleBilling, handleStripeWebhook } from './billing';\r\nimport { handleChatAI } from './chat';\r\nimport { handleReportUser, handleBlockUser } from './safety';\r\nimport { handleMedia } from './media';\r\nimport { getPrompts, saveUserPrompts, getUserPrompts } from './prompts';\r\nimport { getReferralStats, unlockScenario } from './referrals';\r\nimport { handleVibeWindows } from './vibe-windows';\r\nimport { handleChemistry } from './chemistry';\r\nimport { handleVoiceMatching } from './voice-matching';\r\nimport { handleProximity } from './proximity';\r\nimport { handleBoost } from './boost';\r\nimport { handleMutualFriends } from './mutual-friends';\r\nimport { handleNotifications } from './notifications';\r\nimport { handleRewind } from './rewind';\r\nimport { handleSuccessStories } from './success-stories';\r\nimport { handleRecovery } from './recovery';\r\nimport { handleModeration } from './moderation';\r\nimport { handleAdminMetrics } from './admin';\r\nimport { logger } from './logger';\r\nimport { handleApiError, AppError, ServerError, ValidationError } from './errors';\r\n\r\nexport { ChatRoom, MatchLobby } from './durable_objects';\r\n\r\nexport interface Env {\r\n    DB: D1Database;\r\n    GEO_KV: KVNamespace;\r\n    MEDIA_BUCKET: R2Bucket;\r\n    CHAT_ROOM: DurableObjectNamespace;\r\n    MATCH_LOBBY: DurableObjectNamespace;\r\n    LV_AI: AnalyticsEngineDataset;\r\n    AI: any; // Cloudflare Workers AI\r\n    CLOUDFLARE_ACCOUNT_ID?: string;\r\n    CLOUDFLARE_API_TOKEN?: string;\r\n    JWT_SECRET?: string;\r\n    RP_ID?: string;\r\n    RESEND_API_KEY?: string;\r\n}\r\n\r\n/**\r\n * Structured Analytics Helper\r\n * Maps JSON data to Analytics Engine blobs/doubles for cost efficiency\r\n */\r\nexport function trackEvent(env: Env, eventName: string, data: Record<string, any>) {\r\n    try {\r\n        const blobs: string[] = [eventName]; // index 0 is always event name\r\n        const doubles: number[] = [];\r\n\r\n        // Example mapping: \r\n        // blobs: [event_name, user_id, device_type]\r\n        // doubles: [timestamp, value/amount]\r\n\r\n        if (data.userId) blobs.push(data.userId);\r\n        if (data.type) blobs.push(data.type);\r\n\r\n        doubles.push(Date.now());\r\n        if (data.amount) doubles.push(data.amount);\r\n\r\n        void (env.LV_AI as any).writeData({ blobs, doubles });\r\n    } catch (e) {\r\n        console.error(\"Analytics Error:\", e);\r\n    }\r\n}\r\n\r\nexport default {\r\n    async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\r\n        const url = new URL(request.url);\r\n        const startTime = Date.now();\r\n        const requestId = crypto.randomUUID();\r\n\r\n        const corsHeaders = {\r\n            'Access-Control-Allow-Origin': '*',\r\n            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\r\n            'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Auth-Token, CF-Turnstile-Response',\r\n            'Access-Control-Max-Age': '86400',\r\n            'X-Content-Type-Options': 'nosniff',\r\n            'X-Frame-Options': 'DENY',\r\n            'X-XSS-Protection': '1; mode=block',\r\n            'Strict-Transport-Security': 'max-age=31536000; includeSubDomains; preload',\r\n            'Content-Security-Policy': \"default-src 'none'; frame-ancestors 'none';\",\r\n        };\r\n\r\n        if (request.method === 'OPTIONS') {\r\n            return new Response(null, { headers: corsHeaders });\r\n        }\r\n\r\n        try {\r\n            logger.info('request_start', undefined, {\r\n                requestId,\r\n                method: request.method,\r\n                path: url.pathname,\r\n                ip: request.headers.get('cf-connecting-ip')\r\n            });\r\n\r\n            const response = await handleRequest(request, env);\r\n\r\n            // Create a new response with the same body and status, but with CORS headers\r\n            const newResponse = new Response(response.body, response);\r\n            Object.entries(corsHeaders).forEach(([k, v]) => newResponse.headers.set(k, v));\r\n\r\n            const duration = Date.now() - startTime;\r\n            logger.info('request_end', undefined, {\r\n                requestId,\r\n                status: response.status,\r\n                duration\r\n            });\r\n\r\n            return newResponse;\r\n        } catch (e: any) {\r\n            const duration = Date.now() - startTime;\r\n            logger.error('request_error', e, {\r\n                requestId,\r\n                path: url.pathname,\r\n                duration\r\n            });\r\n\r\n            const response = handleApiError(e);\r\n\r\n            // Add CORS to error response too\r\n            const newResponse = new Response(response.body, response);\r\n            Object.entries(corsHeaders).forEach(([k, v]) => newResponse.headers.set(k, v));\r\n            return newResponse;\r\n        }\r\n    },\r\n};\r\n\r\n/**\r\n * CRITICAL: Verify all required secrets are present\r\n * Call this at the start of auth-related operations\r\n */\r\nfunction verifySecrets(env: Env): { valid: boolean; missing: string[] } {\r\n    const missing: string[] = [];\r\n\r\n    if (!env.JWT_SECRET) missing.push('JWT_SECRET');\r\n    if (!env.DB) missing.push('DB (D1 Database)');\r\n    if (!env.MEDIA_BUCKET) missing.push('MEDIA_BUCKET (R2)');\r\n    if (!env.CHAT_ROOM) missing.push('CHAT_ROOM (Durable Object)');\r\n\r\n    return { valid: missing.length === 0, missing };\r\n}\r\n\r\nasync function handleRequest(request: Request, env: Env): Promise<Response> {\r\n    const url = new URL(request.url);\r\n    const path = url.pathname;\r\n    const method = request.method;\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    // HEALTH CHECK ENDPOINT - Critical for monitoring\r\n    if (path === '/health' || path === '/v2/health') {\r\n        const secrets = verifySecrets(env);\r\n\r\n        // Test database read/write separately\r\n        let dbRead = 'ok';\r\n        let dbWrite = 'ok';\r\n\r\n        if (env.DB) {\r\n            try {\r\n                await env.DB.prepare('SELECT 1').first();\r\n            } catch (e) {\r\n                dbRead = 'error';\r\n            }\r\n\r\n            try {\r\n                // We should have a dedicated HealthCheck table for this\r\n                await env.DB.prepare(\r\n                    'INSERT OR REPLACE INTO HealthCheck (id, timestamp) VALUES (1, ?)'\r\n                ).bind(Date.now()).run();\r\n            } catch (e) {\r\n                dbWrite = 'error';\r\n            }\r\n        } else {\r\n            dbRead = 'missing';\r\n            dbWrite = 'missing';\r\n        }\r\n\r\n        // Check external reachability\r\n        let googleAuth = 'untested';\r\n        try {\r\n            // Use GET instead of HEAD, and expect 400 (Bad Request) which means we reached the service\r\n            const googleRes = await fetch('https://oauth2.googleapis.com/tokeninfo', {\r\n                method: 'GET',\r\n                headers: { 'User-Agent': 'LoveVibes/1.0 HealthCheck' }\r\n            });\r\n            googleAuth = googleRes.ok || googleRes.status === 400 ? 'ok' : 'error';\r\n        } catch (e) {\r\n            console.error('Health Check External Error:', e);\r\n            googleAuth = 'error';\r\n        }\r\n\r\n        const allHealthy = secrets.valid && dbRead === 'ok' && googleAuth === 'ok';\r\n        const status = allHealthy ? 'healthy' : 'degraded';\r\n\r\n        return new Response(JSON.stringify({\r\n            success: true,\r\n            status,\r\n            timestamp: new Date().toISOString(),\r\n            version: '1.1.0',\r\n            checks: {\r\n                secrets: secrets.valid ? 'ok' : `missing: ${secrets.missing.join(', ')}`,\r\n                database: {\r\n                    read: dbRead,\r\n                    write: dbWrite\r\n                },\r\n                storage: env.MEDIA_BUCKET ? 'ok' : 'missing',\r\n                durableObjects: env.CHAT_ROOM ? 'ok' : 'missing',\r\n                external: {\r\n                    googleAuth\r\n                }\r\n            }\r\n        }), {\r\n            status: allHealthy ? 200 : 503,\r\n            headers: { 'Content-Type': 'application/json' }\r\n        });\r\n    }\r\n\r\n    // 1. Auth Routes\r\n    if (path.startsWith('/v2/auth')) {\r\n        // Verify critical secrets before auth operations\r\n        const secrets = verifySecrets(env);\r\n        if (!secrets.valid) {\r\n            logger.error('config_error', 'Missing secrets', { missing: secrets.missing });\r\n            throw new AppError('Service configuration error', 503, 'CONFIG_ERROR');\r\n        }\r\n        return await handleAuth(request, env);\r\n    }\r\n\r\n    // 2. Core Feed (Recommendation Engine)\r\n    if (path.startsWith('/v2/recs/core')) {\r\n        return await handleFeed(request, env);\r\n    }\r\n\r\n    // 3. Stripe Webhook (NO AUTH - server-to-server, signature verified internally)\r\n    if (path === '/v2/billing/webhook' && method === 'POST') {\r\n        return await handleStripeWebhook(request, env);\r\n    }\r\n\r\n    // 4. Billing & Monetization\r\n    if (path.startsWith('/v2/billing')) {\r\n        return await handleBilling(request, env);\r\n    }\r\n\r\n    // 4. User Actions (Swipes)\r\n    if (path === '/like' || path === '/pass') {\r\n        return await handleSwipe(request, env);\r\n    }\r\n\r\n    // 5. User Updates (Location Ping, Profile)\r\n    if (path.startsWith('/user')) {\r\n        return await handleUserUpdate(request, env);\r\n    }\r\n\r\n    // 6. Love Vibes Specific (Gifting)\r\n    if (path.startsWith('/v2/gift')) {\r\n        return await handleGifting(request, env);\r\n    }\r\n\r\n    // 7. Chat AI (Icebreakers)\r\n    if (path.startsWith('/v2/chat')) {\r\n        return await handleChatAI(request, env);\r\n    }\r\n\r\n    // 8. Safety & Trust\r\n    if (path === '/v2/safety/report' && method === 'POST') {\r\n        return await handleReportUser(request, env);\r\n    }\r\n    if (path === '/v2/safety/block' && method === 'POST') {\r\n        return await handleBlockUser(request, env);\r\n    }\r\n\r\n    // 9. Media Uploads (R2)\r\n    if (path.startsWith('/v2/media')) {\r\n        return await handleMedia(request, env);\r\n    }\r\n\r\n    // 10. Profile Prompts\r\n    if (path === '/v2/prompts' && method === 'GET') {\r\n        const prompts = await getPrompts(env);\r\n        return new Response(JSON.stringify({ success: true, data: prompts }), {\r\n            headers: jsonHeaders\r\n        });\r\n    }\r\n    if (path === '/v2/user/prompts' && method === 'POST') {\r\n        const body = await request.json() as any;\r\n        const result = await saveUserPrompts(env, body.user_id, body.prompts);\r\n        return new Response(JSON.stringify({ success: true, data: result }), {\r\n            headers: jsonHeaders\r\n        });\r\n    }\r\n    if (path.startsWith('/v2/user/') && path.endsWith('/prompts') && method === 'GET') {\r\n        const userId = path.split('/')[3];\r\n        const prompts = await getUserPrompts(env, userId);\r\n        return new Response(JSON.stringify({ success: true, data: prompts }), {\r\n            headers: jsonHeaders\r\n        });\r\n    }\r\n\r\n    // 11. Referral System (The Resonance Circle)\r\n    if (path === '/v2/referrals/stats' && method === 'GET') {\r\n        const url = new URL(request.url);\r\n        const userId = url.searchParams.get('userId');\r\n        if (!userId) throw new ValidationError('Missing userId');\r\n\r\n        const stats = await getReferralStats(env, userId);\r\n        return new Response(JSON.stringify({ success: true, data: stats }), {\r\n            headers: jsonHeaders\r\n        });\r\n    }\r\n    if (path === '/v2/referrals/unlock' && method === 'POST') {\r\n        const body = await request.json() as any; // { userId, scenarioType }\r\n        if (!body.userId || !body.scenarioType) throw new ValidationError('Missing userId or scenarioType');\r\n\r\n        const result = await unlockScenario(env, body.userId, body.scenarioType);\r\n        return new Response(JSON.stringify({ success: true, data: result }), {\r\n            headers: jsonHeaders\r\n        });\r\n    }\r\n\r\n    // 12. Vibe Windows\r\n    if (path.startsWith('/v2/vibe-windows')) {\r\n        return await handleVibeWindows(request, env);\r\n    }\r\n\r\n    // 13. Chemistry Test\r\n    if (path.startsWith('/v2/chemistry')) {\r\n        return await handleChemistry(request, env);\r\n    }\r\n\r\n    // 14. Voice Matching\r\n    if (path.startsWith('/v2/voice')) {\r\n        return await handleVoiceMatching(request, env);\r\n    }\r\n\r\n    // 15. Proximity Alerts\r\n    if (path.startsWith('/v2/proximity')) {\r\n        return await handleProximity(request, env);\r\n    }\r\n\r\n    // 16. Profile Boost\r\n    if (path.startsWith('/v2/boost')) {\r\n        return await handleBoost(request, env);\r\n    }\r\n\r\n    // 17. Mutual Friends & Social\r\n    if (path.startsWith('/v2/social')) {\r\n        return await handleMutualFriends(request, env);\r\n    }\r\n\r\n    // 18. Push Notifications\r\n    if (path.startsWith('/v2/notifications')) {\r\n        return await handleNotifications(request, env);\r\n    }\r\n\r\n    // 19. Rewind Feature\r\n    if (path.startsWith('/v2/rewind')) {\r\n        return await handleRewind(request, env);\r\n    }\r\n\r\n    // 20. Success Stories\r\n    if (path.startsWith('/v2/success-stories')) {\r\n        return await handleSuccessStories(request, env);\r\n    }\r\n\r\n    // 21. Account Recovery\r\n    if (path.startsWith('/v2/recovery')) {\r\n        return await handleRecovery(request, env);\r\n    }\r\n\r\n    // 22. Admin Moderation\r\n    if (path.startsWith('/v2/admin/moderation')) {\r\n        return await handleModeration(request, env);\r\n    }\r\n\r\n    // 23. Admin Metrics\r\n    if (path === '/v2/admin/metrics') {\r\n        return await handleAdminMetrics(request, env);\r\n    }\r\n\r\n    // 8. Durable Object Routes (Chat / WebSocket)\r\n    if (path.startsWith('/ws/chat')) {\r\n        const upgradeHeader = request.headers.get('Upgrade');\r\n        if (!upgradeHeader || upgradeHeader !== 'websocket') {\r\n            return new Response('Expected Upgrade: websocket', { status: 426 });\r\n        }\r\n        const matchId = url.searchParams.get('match_id');\r\n        if (!matchId) return new Response(\"Missing match_id\", { status: 400 });\r\n\r\n        const id = env.CHAT_ROOM.idFromName(matchId);\r\n        const stub = env.CHAT_ROOM.get(id);\r\n        return stub.fetch(request);\r\n    }\r\n\r\n    return new Response('Not Found', { status: 404 });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\logger.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[207,210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[207,210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[655,658],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[655,658],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[799,802],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[799,802],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[943,946],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[943,946],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1054,1057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1054,1057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1081,1084],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1081,1084],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export type LogLevel = 'DEBUG' | 'INFO' | 'WARN' | 'ERROR';\r\n\r\nexport interface LogEntry {\r\n    level: LogLevel;\r\n    timestamp: string;\r\n    event: string;\r\n    message?: string;\r\n    data?: Record<string, any>;\r\n    requestId?: string;\r\n    path?: string;\r\n    userId?: string;\r\n}\r\n\r\nexport const logger = {\r\n    log(entry: Partial<LogEntry>) {\r\n        const fullEntry: LogEntry = {\r\n            level: 'INFO',\r\n            timestamp: new Date().toISOString(),\r\n            event: 'unknown',\r\n            ...entry\r\n        };\r\n\r\n        console.log(JSON.stringify(fullEntry));\r\n    },\r\n\r\n    info(event: string, message?: string, data?: Record<string, any>) {\r\n        this.log({ level: 'INFO', event, message, data });\r\n    },\r\n\r\n    debug(event: string, message?: string, data?: Record<string, any>) {\r\n        this.log({ level: 'DEBUG', event, message, data });\r\n    },\r\n\r\n    warn(event: string, message?: string, data?: Record<string, any>) {\r\n        this.log({ level: 'WARN', event, message, data });\r\n    },\r\n\r\n    error(event: string, error: any, data?: Record<string, any>) {\r\n        this.log({\r\n            level: 'ERROR',\r\n            event,\r\n            message: error instanceof Error ? error.message : String(error),\r\n            data: {\r\n                ...(data || {}),\r\n                stack: error instanceof Error ? error.stack : undefined\r\n            }\r\n        });\r\n    }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\media-optimization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\media.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1627,1630],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1627,1630],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1689,1692],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1689,1692],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2417,2420],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2417,2420],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3382,3385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3382,3385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3683,3686],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3683,3686],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4443,4446],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4443,4446],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":118,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4726,4729],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4726,4729],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Media Module\r\n * Handles R2 Uploads for Photos and Video Intros with AI Moderation Hooks\r\n */\r\nimport { Env } from './index';\r\nimport { verifyAuth } from './auth';\r\nimport { AuthenticationError, AppError, ServerError, NotFoundError } from './errors';\r\nimport { logger } from './logger';\r\n\r\nexport async function handleMedia(request: Request, env: Env): Promise<Response> {\r\n    const url = new URL(request.url);\r\n    const method = request.method;\r\n    const path = url.pathname;\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    // 0. PUBLIC ACCESS: Serve Image Directly (GET /v2/media/public/:key)\r\n    if (method === 'GET' && path.startsWith('/v2/media/public/')) {\r\n        let key = path.replace('/v2/media/public/', '');\r\n\r\n        try {\r\n            key = decodeURIComponent(key);\r\n        } catch (_e) {\r\n            logger.error('media_decode_error', 'Failed to decode key', { key });\r\n        }\r\n\r\n        const object = await env.MEDIA_BUCKET.get(key);\r\n\r\n        if (!object) {\r\n            throw new NotFoundError('Media object');\r\n        }\r\n\r\n        const headers = new Headers();\r\n        object.writeHttpMetadata(headers);\r\n        headers.set('etag', object.httpEtag);\r\n        headers.set('Cache-Control', 'public, max-age=31536000');\r\n\r\n        return new Response(object.body, { headers });\r\n    }\r\n\r\n    const userId = await verifyAuth(request, env);\r\n    if (!userId) throw new AuthenticationError();\r\n\r\n    // 1. Get Direct Upload URL for Cloudflare Stream\r\n    if (method === 'GET' && pathMatches(path, '/v2/media/video-upload-url')) {\r\n        const accountId = (env as any).CLOUDFLARE_ACCOUNT_ID;\r\n        const apiToken = (env as any).CLOUDFLARE_API_TOKEN;\r\n\r\n        if (!accountId || !apiToken) {\r\n            throw new ServerError(\"Media processing service not configured\");\r\n        }\r\n\r\n        const streamResponse = await fetch(\r\n            `https://api.cloudflare.com/client/v4/accounts/${accountId}/stream/direct_upload`,\r\n            {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Authorization': `Bearer ${apiToken}`,\r\n                    'Content-Type': 'application/json'\r\n                },\r\n                body: JSON.stringify({\r\n                    maxDurationSeconds: 60,\r\n                    meta: { userId, type: 'video_intro' }\r\n                })\r\n            }\r\n        );\r\n\r\n        const data: any = await streamResponse.json();\r\n        return new Response(JSON.stringify({\r\n            success: true,\r\n            data: {\r\n                uploadURL: data.result.uploadURL,\r\n                uid: data.result.uid\r\n            }\r\n        }), { headers: jsonHeaders });\r\n    }\r\n\r\n    // 2. Direct Upload to R2 (Photos)\r\n    if (method === 'POST' && pathMatches(url.pathname, '/v2/media/upload')) {\r\n        const formData = await request.formData();\r\n        const file = formData.get('file') as unknown as File;\r\n        const type = String(formData.get('type') || 'photo');\r\n\r\n        if (!file) throw new AppError(\"No file provided\", 400);\r\n\r\n        const fileId = crypto.randomUUID();\r\n        const rawExt = file.name.split('.').pop() || 'jpg';\r\n        const extension = rawExt.replace(/[^a-z0-9]/gi, '').toLowerCase();\r\n\r\n        const key = `users/${userId}/${type}s/${fileId}.${extension}`;\r\n\r\n        await env.MEDIA_BUCKET.put(key, file.stream() as any, {\r\n            httpMetadata: { contentType: file.type }\r\n        });\r\n\r\n        const workerUrl = new URL(request.url).origin;\r\n        const publicUrl = `${workerUrl}/v2/media/public/${key}`;\r\n\r\n        // 3. Real AI Moderation (Classification check)\r\n        try {\r\n            const aiResult: any = await env.AI.run('@cf/microsoft/resnet-50', {\r\n                image: Array.from(new Uint8Array(await file.arrayBuffer()))\r\n            });\r\n            // ResNet-50 returns labels like 'person', 'clothing', etc.\r\n            // We can log this for human moderation or automatically flag suspicious uploads.\r\n            logger.info('media_ai_moderated', undefined, { userId, type, key, labels: aiResult.slice(0, 3) });\r\n        } catch (aiError) {\r\n            logger.warn('media_ai_moderation_failed', 'AI Moderation scan failed, proceeding with caution', { error: aiError });\r\n        }\r\n\r\n        if (type === 'video') {\r\n            const streamUid = formData.get('stream_uid');\r\n            const videoUrl = streamUid ? `https://customer-${(env as any).CLOUDFLARE_ACCOUNT_ID}.cloudflarestream.com/${streamUid}/watch` : publicUrl;\r\n\r\n            await env.DB.prepare(\r\n                \"UPDATE Users SET video_intro_url = ? WHERE id = ?\"\r\n            ).bind(videoUrl, userId).run();\r\n        } else {\r\n            const { results }: any = await env.DB.prepare(\r\n                \"SELECT photo_urls FROM Users WHERE id = ?\"\r\n            ).bind(userId).all();\r\n\r\n            let photos = [];\r\n            try {\r\n                photos = JSON.parse(results[0].photo_urls || '[]');\r\n            } catch (e) {\r\n                logger.error('media_json_parse_error', 'Failed to parse photo urls', { error: e });\r\n            }\r\n\r\n            photos.push(publicUrl);\r\n\r\n            await env.DB.prepare(\r\n                \"UPDATE Users SET photo_urls = ?, main_photo_url = ? WHERE id = ?\"\r\n            ).bind(JSON.stringify(photos), photos[0], userId).run();\r\n        }\r\n\r\n        logger.info('media_uploaded', undefined, { userId, type, key });\r\n\r\n        return new Response(JSON.stringify({\r\n            success: true,\r\n            data: {\r\n                status: \"uploaded\",\r\n                url: publicUrl\r\n            }\r\n        }), { headers: jsonHeaders });\r\n    }\r\n\r\n    throw new NotFoundError(\"Media route\");\r\n}\r\n\r\nfunction pathMatches(path: string, target: string) {\r\n    return path === target || path === target + '/';\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\moderation.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ValidationError' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":46,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ValidationError"},"fix":{"range":[191,208],"text":""},"desc":"Remove unused variable \"ValidationError\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1053,1056],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1053,1056],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":45,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":45,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":130,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4098,4101],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4098,4101],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":137,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4390,4393],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4390,4393],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Content Moderation Dashboard (Admin)\r\n// Admin panel for reviewing flagged content and user reports\r\n\r\nimport { Env } from './index'\r\nimport { z } from 'zod';\r\nimport { AuthenticationError, ValidationError, NotFoundError, AppError } from './errors';\r\nimport { logger } from './logger';\r\n\r\n// Zod Schema\r\nconst ReviewReportSchema = z.object({\r\n    report_id: z.string().uuid(),\r\n    action: z.enum(['DISMISS', 'BAN_USER', 'WARN_USER']),\r\n    notes: z.string().max(1000).default(''),\r\n});\r\n\r\nexport interface ModerationReport {\r\n    id: string\r\n    reporter_id: string\r\n    reported_id: string\r\n    reported_name: string\r\n    reason: string\r\n    details: string\r\n    timestamp: number\r\n    status: 'PENDING' | 'REVIEWED' | 'DISMISSED'\r\n    admin_notes?: string\r\n    reviewed_by?: string\r\n    reviewed_at?: number\r\n    auto_flagged?: boolean\r\n    toxic_score?: number\r\n}\r\n\r\n// AI Content Moderation Helper\r\nexport async function autoModerateContent(env: Env, text: string): Promise<{ toxic: boolean; score: number }> {\r\n    try {\r\n        const result: any = await env.AI.run('@cf/microsoft/distilbert-base-uncased-mnli', {\r\n            text: text\r\n        });\r\n\r\n        const toxicScore = result.label === 'LABEL_1' ? result.score : 0;\r\n\r\n        return {\r\n            toxic: toxicScore > 0.85,\r\n            score: toxicScore\r\n        };\r\n    } catch (e) {\r\n        return { toxic: false, score: 0 };\r\n    }\r\n}\r\n\r\n// GET /admin/moderation/reports - Get all pending reports\r\nexport async function getPendingReports(env: Env, adminId: string): Promise<ModerationReport[]> {\r\n    const admin = await env.DB.prepare('SELECT id FROM Users WHERE id = ? AND subscription_tier = ?')\r\n        .bind(adminId, 'admin')\r\n        .first()\r\n\r\n    if (!admin) {\r\n        throw new AuthenticationError('Admin access required');\r\n    }\r\n\r\n    const results = await env.DB.prepare(\r\n        `SELECT \r\n      r.id,\r\n      r.reporter_id,\r\n      r.reported_id,\r\n      u.name as reported_name,\r\n      r.reason,\r\n      r.details,\r\n      r.timestamp,\r\n      r.status,\r\n      r.admin_notes,\r\n      r.reviewed_by,\r\n      r.reviewed_at\r\n    FROM Reports r\r\n    LEFT JOIN Users u ON r.reported_id = u.id\r\n    WHERE r.status = 'PENDING'\r\n    ORDER BY r.timestamp DESC\r\n    LIMIT 100`\r\n    ).all()\r\n\r\n    return results.results as unknown as ModerationReport[]\r\n}\r\n\r\n// POST /admin/moderation/review - Review a report\r\nexport async function reviewReport(\r\n    env: Env,\r\n    adminId: string,\r\n    reportId: string,\r\n    action: 'DISMISS' | 'BAN_USER' | 'WARN_USER',\r\n    notes: string\r\n): Promise<{ success: boolean; message: string }> {\r\n    const admin = await env.DB.prepare('SELECT id FROM Users WHERE id = ? AND subscription_tier = ?')\r\n        .bind(adminId, 'admin')\r\n        .first()\r\n\r\n    if (!admin) {\r\n        throw new AuthenticationError('Admin access required');\r\n    }\r\n\r\n    try {\r\n        const now = Math.floor(Date.now() / 1000)\r\n\r\n        const report = await env.DB.prepare('SELECT reported_id FROM Reports WHERE id = ?')\r\n            .bind(reportId)\r\n            .first()\r\n\r\n        if (!report) {\r\n            throw new NotFoundError('Report');\r\n        }\r\n\r\n        await env.DB.prepare(\r\n            'UPDATE Reports SET status = ?, admin_notes = ?, reviewed_by = ?, reviewed_at = ? WHERE id = ?'\r\n        )\r\n            .bind('REVIEWED', notes, adminId, now, reportId)\r\n            .run()\r\n\r\n        if (action === 'BAN_USER') {\r\n            await env.DB.prepare('UPDATE Users SET subscription_tier = ? WHERE id = ?')\r\n                .bind('banned', report.reported_id)\r\n                .run()\r\n        } else if (action === 'WARN_USER') {\r\n            await env.DB.prepare(\r\n                'INSERT INTO ModerationActions (user_id, action, reason, admin_id, timestamp) VALUES (?, ?, ?, ?, ?)'\r\n            )\r\n                .bind(report.reported_id, 'WARNING', notes, adminId, now)\r\n                .run()\r\n        }\r\n\r\n        logger.info('report_reviewed', undefined, { adminId, reportId, action });\r\n        return { success: true, message: 'Report reviewed successfully' }\r\n    } catch (error: any) {\r\n        if (error instanceof AppError) throw error;\r\n        throw new AppError('Report review failed', 500, 'REVIEW_FAILED', error);\r\n    }\r\n}\r\n\r\n// GET /admin/moderation/stats - Get moderation statistics\r\nexport async function getModerationStats(env: Env, adminId: string): Promise<any> {\r\n    const admin = await env.DB.prepare('SELECT id FROM Users WHERE id = ? AND subscription_tier = ?')\r\n        .bind(adminId, 'admin')\r\n        .first()\r\n\r\n    if (!admin) {\r\n        throw new AuthenticationError('Admin access required');\r\n    }\r\n\r\n    const stats = await env.DB.prepare(\r\n        `SELECT \r\n      COUNT(*) as total_reports,\r\n      SUM(CASE WHEN status = 'PENDING' THEN 1 ELSE 0 END) as pending,\r\n      SUM(CASE WHEN status = 'REVIEWED' THEN 1 ELSE 0 END) as reviewed,\r\n      SUM(CASE WHEN status = 'DISMISSED' THEN 1 ELSE 0 END) as dismissed\r\n    FROM Reports`\r\n    ).first()\r\n\r\n    return stats\r\n}\r\n\r\n// HTTP Handler for moderation routes\r\nexport async function handleModeration(request: Request, env: Env): Promise<Response> {\r\n    const url = new URL(request.url);\r\n    const path = url.pathname;\r\n    const method = request.method;\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    const adminId = request.headers.get('X-Auth-Token') || url.searchParams.get('admin_id');\r\n\r\n    if (!adminId) throw new AuthenticationError();\r\n\r\n    if (path.endsWith('/reports') && method === 'GET') {\r\n        const reports = await getPendingReports(env, adminId);\r\n        return new Response(JSON.stringify({ success: true, data: reports }), {\r\n            headers: jsonHeaders\r\n        });\r\n    }\r\n\r\n    if (path.endsWith('/review') && method === 'POST') {\r\n        const body = ReviewReportSchema.parse(await request.json());\r\n        const result = await reviewReport(env, adminId, body.report_id, body.action, body.notes);\r\n        return new Response(JSON.stringify(result), { headers: jsonHeaders });\r\n    }\r\n\r\n    if (path.endsWith('/stats') && method === 'GET') {\r\n        const stats = await getModerationStats(env, adminId);\r\n        return new Response(JSON.stringify({ success: true, data: stats }), {\r\n            headers: jsonHeaders\r\n        });\r\n    }\r\n\r\n    throw new AppError('Method not allowed', 405, 'METHOD_NOT_ALLOWED');\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\mutual-friends.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1899,1902],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1899,1902],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2957,2960],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2957,2960],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":131,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4454,4457],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4454,4457],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":181,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":181,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6318,6321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6318,6321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Mutual Friend Introduction Protocol\r\n// Leverage real social graphs for trusted introductions\r\n\r\nimport { Env } from './index'\r\nimport { z } from 'zod';\r\nimport { AuthenticationError, ValidationError, NotFoundError, AppError } from './errors';\r\nimport { logger } from './logger';\r\n\r\n// Zod Schemas\r\nconst ImportContactsSchema = z.object({\r\n    contacts: z.array(z.object({\r\n        phone: z.string().min(5),\r\n        name: z.string().min(1),\r\n    })),\r\n});\r\n\r\nconst RequestIntroSchema = z.object({\r\n    target_id: z.string().uuid(),\r\n    mutual_friend_id: z.string().uuid(),\r\n});\r\n\r\nconst RespondIntroSchema = z.object({\r\n    request_id: z.string().uuid(),\r\n    response: z.enum(['approved', 'declined']),\r\n    message: z.string().optional(),\r\n});\r\n\r\nexport interface MutualFriendInfo {\r\n    friend_id: string\r\n    friend_name: string\r\n    connection_type: string\r\n}\r\n\r\n// POST /api/social/import-contacts - Import hashed contacts\r\nexport async function importContacts(\r\n    env: Env,\r\n    userId: string,\r\n    contactsRaw: z.infer<typeof ImportContactsSchema>\r\n): Promise<{ success: boolean; imported_count: number }> {\r\n    const { contacts } = contactsRaw;\r\n    const now = Math.floor(Date.now() / 1000)\r\n    let imported = 0\r\n\r\n    try {\r\n        for (const contact of contacts) {\r\n            // Hash phone number for privacy\r\n            const hash = await hashPhoneNumber(contact.phone)\r\n\r\n            await env.DB.prepare(\r\n                `INSERT OR IGNORE INTO SocialConnections (user_id, friend_hash, connection_type, friend_name, created_at) \r\n         VALUES (?, ?, ?, ?, ?)`\r\n            )\r\n                .bind(userId, hash, 'phone', contact.name, now)\r\n                .run()\r\n\r\n            imported++\r\n        }\r\n\r\n        logger.info('contacts_imported', undefined, { userId, count: imported });\r\n        return { success: true, imported_count: imported }\r\n    } catch (error: any) {\r\n        throw new AppError('Failed to import contacts', 500, 'CONTACT_IMPORT_FAILED', error);\r\n    }\r\n}\r\n\r\n// GET /api/social/mutual-friends/:targetId - Find mutual connections\r\nexport async function findMutualFriends(\r\n    env: Env,\r\n    userId: string,\r\n    targetId: string\r\n): Promise<MutualFriendInfo[]> {\r\n    // Find users who are connected to both userId and targetId\r\n    const results = await env.DB.prepare(\r\n        `SELECT DISTINCT u.id, u.name, sc1.connection_type\r\n     FROM SocialConnections sc1\r\n     JOIN SocialConnections sc2 ON sc1.friend_hash = sc2.friend_hash\r\n     JOIN Users u ON u.id = sc1.user_id\r\n     WHERE sc1.user_id != ? \r\n     AND sc2.user_id != ?\r\n     AND sc1.user_id = sc2.user_id\r\n     AND (\r\n       (sc1.friend_hash IN (SELECT friend_hash FROM SocialConnections WHERE user_id = ?)) AND\r\n       (sc2.friend_hash IN (SELECT friend_hash FROM SocialConnections WHERE user_id = ?))\r\n     )\r\n     LIMIT 10`\r\n    )\r\n        .bind(userId, targetId, userId, targetId)\r\n        .all()\r\n\r\n    return results.results.map((r: any) => ({\r\n        friend_id: r.id,\r\n        friend_name: r.name,\r\n        connection_type: r.connection_type,\r\n    }))\r\n}\r\n\r\n// POST /api/social/request-intro - Request introduction from mutual friend\r\nexport async function requestIntroduction(\r\n    env: Env,\r\n    requesterId: string,\r\n    targetId: string,\r\n    mutualFriendId: string\r\n): Promise<{ success: boolean; message: string }> {\r\n    try {\r\n        const now = Math.floor(Date.now() / 1000)\r\n        const requestId = crypto.randomUUID()\r\n\r\n        // Get requester and target names\r\n        const requester = await env.DB.prepare('SELECT name FROM Users WHERE id = ?')\r\n            .bind(requesterId)\r\n            .first()\r\n        const target = await env.DB.prepare('SELECT name FROM Users WHERE id = ?')\r\n            .bind(targetId)\r\n            .first()\r\n\r\n        if (!requester || !target) {\r\n            throw new NotFoundError('User');\r\n        }\r\n\r\n        // Create introduction request\r\n        await env.DB.prepare(\r\n            `INSERT INTO IntroductionRequests (id, requester_id, target_id, mutual_friend_id, status, created_at) \r\n       VALUES (?, ?, ?, ?, ?, ?)`\r\n        )\r\n            .bind(requestId, requesterId, targetId, mutualFriendId, 'pending', now)\r\n            .run()\r\n\r\n        // Send notification to mutual friend\r\n        logger.info('intro_requested', undefined, { requesterId, targetId, mutualFriendId });\r\n        return { success: true, message: 'Introduction request sent!' }\r\n    } catch (error: any) {\r\n        if (error instanceof AppError) throw error;\r\n        throw new AppError('Failed to send intro request', 500, 'INTRO_REQUEST_FAILED', error);\r\n    }\r\n}\r\n\r\n// POST /api/social/respond-intro - Friend responds to introduction request\r\nexport async function respondToIntroduction(\r\n    env: Env,\r\n    requestId: string,\r\n    friendId: string,\r\n    response: 'approved' | 'declined',\r\n    message?: string\r\n): Promise<{ success: boolean; match_created?: boolean }> {\r\n    try {\r\n        const now = Math.floor(Date.now() / 1000)\r\n\r\n        // Get request details\r\n        const request = await env.DB.prepare(\r\n            'SELECT requester_id, target_id FROM IntroductionRequests WHERE id = ? AND mutual_friend_id = ?'\r\n        )\r\n            .bind(requestId, friendId)\r\n            .first()\r\n\r\n        if (!request) {\r\n            throw new NotFoundError('Introduction request');\r\n        }\r\n\r\n        // Update request status\r\n        await env.DB.prepare(\r\n            'UPDATE IntroductionRequests SET status = ?, friend_message = ?, responded_at = ? WHERE id = ?'\r\n        )\r\n            .bind(response, message || '', now, requestId)\r\n            .run()\r\n\r\n        if (response === 'approved') {\r\n            // Create instant match\r\n            const matchId = crypto.randomUUID()\r\n            await env.DB.prepare(\r\n                'INSERT INTO Matches (id, user_a_id, user_b_id, created_at) VALUES (?, ?, ?, ?)'\r\n            )\r\n                .bind(matchId, request.requester_id, request.target_id, now)\r\n                .run()\r\n\r\n            logger.info('intro_approved', undefined, { friendId, requestId, matchId });\r\n            return { success: true, match_created: true }\r\n        }\r\n\r\n        logger.info('intro_declined', undefined, { friendId, requestId });\r\n        return { success: true, match_created: false }\r\n    } catch (error: any) {\r\n        if (error instanceof AppError) throw error;\r\n        throw new AppError('Failed to respond to intro', 500, 'INTRO_RESPONSE_FAILED', error);\r\n    }\r\n}\r\n\r\nasync function hashPhoneNumber(phone: string): Promise<string> {\r\n    // Normalize phone number (remove spaces, dashes, etc.)\r\n    const normalized = phone.replace(/\\D/g, '')\r\n\r\n    // Hash with SHA-256\r\n    const encoder = new TextEncoder()\r\n    const data = encoder.encode(normalized)\r\n    const hash = await crypto.subtle.digest('SHA-256', data)\r\n\r\n    return Array.from(new Uint8Array(hash))\r\n        .map((b) => b.toString(16).padStart(2, '0'))\r\n        .join('')\r\n}\r\n\r\nexport async function handleMutualFriends(request: Request, env: Env): Promise<Response> {\r\n    const { verifyAuth } = await import('./auth');\r\n    const userId = await verifyAuth(request, env);\r\n    if (!userId) throw new AuthenticationError();\r\n\r\n    const url = new URL(request.url);\r\n    const path = url.pathname;\r\n    const method = request.method;\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    if (path === '/v2/social/import' && method === 'POST') {\r\n        const body = ImportContactsSchema.parse(await request.json());\r\n        const result = await importContacts(env, userId, body);\r\n        return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n    }\r\n\r\n    if (path.startsWith('/v2/social/mutual/') && method === 'GET') {\r\n        const targetId = path.split('/').pop();\r\n        if (!targetId) throw new ValidationError(\"Missing target ID\");\r\n        const result = await findMutualFriends(env, userId, targetId);\r\n        return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n    }\r\n\r\n    if (path === '/v2/social/request-intro' && method === 'POST') {\r\n        const body = RequestIntroSchema.parse(await request.json());\r\n        const result = await requestIntroduction(env, userId, body.target_id, body.mutual_friend_id);\r\n        return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n    }\r\n\r\n    if (path === '/v2/social/respond-intro' && method === 'POST') {\r\n        const body = RespondIntroSchema.parse(await request.json());\r\n        const result = await respondToIntroduction(env, body.request_id, userId, body.response, body.message);\r\n        return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n    }\r\n\r\n    return new Response(JSON.stringify({ error: 'Route not found' }), {\r\n        status: 404,\r\n        headers: jsonHeaders\r\n    });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\notifications.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[810,813],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[810,813],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":51,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1703,1706],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1703,1706],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2152,2155],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2152,2155],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2911,2914],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2911,2914],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":135,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4473,4476],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4473,4476],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":139,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4698,4701],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4698,4701],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Push Notifications Infrastructure\r\n// Web Push API integration for re-engagement\r\n\r\nimport { Env } from './index'\r\nimport { z } from 'zod';\r\nimport { AuthenticationError, ValidationError, AppError } from './errors';\r\nimport { logger } from './logger';\r\nimport { verifyAuth } from './auth';\r\n\r\n// Zod Schema\r\nconst PushSubscriptionSchema = z.object({\r\n    endpoint: z.string().url(),\r\n    keys: z.object({\r\n        p256dh: z.string().min(1),\r\n        auth: z.string().min(1),\r\n    }),\r\n});\r\n\r\nexport interface PushSubscriptionResponse {\r\n    user_id: string\r\n    endpoint: string\r\n    p256dh: string\r\n    auth: string\r\n    created_at: number\r\n}\r\n\r\n// POST /api/notifications/subscribe - Save push subscription\r\nexport async function subscribeToPush(\r\n    env: Env,\r\n    userId: string,\r\n    subscriptionRaw: any\r\n): Promise<{ success: boolean; message: string }> {\r\n    try {\r\n        const subscription = PushSubscriptionSchema.parse(subscriptionRaw);\r\n        const now = Math.floor(Date.now() / 1000)\r\n\r\n        // Delete old subscriptions for this user\r\n        await env.DB.prepare('DELETE FROM PushSubscriptions WHERE user_id = ?')\r\n            .bind(userId)\r\n            .run()\r\n\r\n        // Save new subscription\r\n        await env.DB.prepare(\r\n            'INSERT INTO PushSubscriptions (user_id, endpoint, p256dh, auth, created_at) VALUES (?, ?, ?, ?, ?)'\r\n        )\r\n            .bind(userId, subscription.endpoint, subscription.keys.p256dh, subscription.keys.auth, now)\r\n            .run()\r\n\r\n        logger.info('push_subscribed', undefined, { userId, endpoint: subscription.endpoint });\r\n        return { success: true, message: 'Subscribed to push notifications' }\r\n    } catch (error: any) {\r\n        if (error instanceof z.ZodError) throw new ValidationError(error.errors[0].message);\r\n        throw new AppError('Failed to subscribe to push', 500, 'SUBSCRIBE_ERROR', error);\r\n    }\r\n}\r\n\r\n// Send push notification to user\r\nexport async function sendPushNotification(\r\n    env: Env,\r\n    userId: string,\r\n    notification: {\r\n        title: string\r\n        body: string\r\n        icon?: string\r\n        badge?: string\r\n        data?: any\r\n    }\r\n): Promise<{ success: boolean }> {\r\n    try {\r\n        const sub = await env.DB.prepare(\r\n            'SELECT endpoint, p256dh, auth FROM PushSubscriptions WHERE user_id = ?'\r\n        )\r\n            .bind(userId)\r\n            .first()\r\n\r\n        if (!sub) return { success: false }\r\n\r\n        // Real Delivery would require VAPID signing using web-crypto\r\n        // This is ready to be hooked into a Cloudflare Worker service for Web Push\r\n        // For now, we record the intent and trigger the internal logger\r\n        logger.info('push_notification_dispatched', undefined, {\r\n            userId,\r\n            endpoint: sub.endpoint,\r\n            title: notification.title\r\n        });\r\n\r\n        return { success: true }\r\n    } catch (error: any) {\r\n        logger.error('push_failed', error, { userId });\r\n        return { success: false }\r\n    }\r\n}\r\n\r\n// Notification triggers\r\nexport async function notifyNewMatch(env: Env, userId: string, matchName: string): Promise<void> {\r\n    await sendPushNotification(env, userId, {\r\n        title: ' New Match!',\r\n        body: `You matched with ${matchName}!`,\r\n        data: { type: 'match', screen: 'matches' },\r\n    })\r\n}\r\n\r\nexport async function notifyNewMessage(\r\n    env: Env,\r\n    userId: string,\r\n    senderName: string,\r\n    message: string\r\n): Promise<void> {\r\n    await sendPushNotification(env, userId, {\r\n        title: ` ${senderName}`,\r\n        body: message.substring(0, 100),\r\n        data: { type: 'message', screen: 'chat' },\r\n    })\r\n}\r\n\r\nexport async function notifyProfileView(env: Env, userId: string): Promise<void> {\r\n    await sendPushNotification(env, userId, {\r\n        title: ' Someone viewed your profile',\r\n        body: 'See who checked you out!',\r\n        data: { type: 'view', screen: 'profile' },\r\n    })\r\n}\r\n\r\nexport async function handleNotifications(request: Request, env: Env): Promise<Response> {\r\n    const userId = await verifyAuth(request, env);\r\n    if (!userId) throw new AuthenticationError();\r\n\r\n    const url = new URL(request.url);\r\n    const path = url.pathname;\r\n    const method = request.method;\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    try {\r\n        if (path === '/v2/notifications/subscribe' && method === 'POST') {\r\n            const body = await request.json() as any;\r\n            const result = await subscribeToPush(env, userId, body.subscription);\r\n            return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n        }\r\n    } catch (e: any) {\r\n        if (e instanceof z.ZodError) throw new ValidationError(e.errors[0].message);\r\n        throw e;\r\n    }\r\n\r\n    throw new AppError('Route not found', 404, 'NOT_FOUND');\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\prompts.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1191,1194],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1191,1194],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1448,1451],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1448,1451],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3301,3304],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3301,3304],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3324,3327],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3324,3327],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Profile Prompts API\r\n// Handles prompt library and user responses\r\n\r\nimport { Env } from './index'\r\nimport { z } from 'zod';\r\nimport { ValidationError, AppError } from './errors';\r\nimport { logger } from './logger';\r\n\r\nconst PromptResponseSchema = z.object({\r\n    prompt_id: z.string().min(1),\r\n    response_text: z.string().min(1).max(200),\r\n    display_order: z.number().int().min(0).max(2),\r\n});\r\n\r\nconst SavePromptsSchema = z.array(PromptResponseSchema).length(3);\r\n\r\nexport interface ProfilePrompt {\r\n    id: string\r\n    prompt_text: string\r\n    category: string\r\n    is_active: boolean\r\n}\r\n\r\nexport interface UserPromptResponse {\r\n    user_id: string\r\n    prompt_id: string\r\n    response_text: string\r\n    display_order: number\r\n    created_at: number\r\n    updated_at: number\r\n}\r\n\r\n// GET /api/prompts - Get all available prompts\r\nexport async function getPrompts(env: Env): Promise<ProfilePrompt[]> {\r\n    try {\r\n        const results = await env.DB.prepare(\r\n            'SELECT id, prompt_text, category, is_active FROM ProfilePrompts WHERE is_active = TRUE ORDER BY category, id'\r\n        ).all()\r\n\r\n        return results.results as unknown as ProfilePrompt[]\r\n    } catch (e: any) {\r\n        throw new AppError('Failed to fetch prompts', 500, 'FETCH_PROMPTS_ERROR', e);\r\n    }\r\n}\r\n\r\n// POST /api/user/prompts - Save user's prompt responses\r\nexport async function saveUserPrompts(\r\n    env: Env,\r\n    userId: string,\r\n    promptsRaw: any\r\n): Promise<{ success: boolean; message: string }> {\r\n    try {\r\n        const prompts = SavePromptsSchema.parse(promptsRaw);\r\n        const now = Math.floor(Date.now() / 1000)\r\n\r\n        // Delete existing responses\r\n        await env.DB.prepare('DELETE FROM UserPromptResponses WHERE user_id = ?').bind(userId).run()\r\n\r\n        // Insert new responses\r\n        for (const prompt of prompts) {\r\n            await env.DB.prepare(\r\n                'INSERT INTO UserPromptResponses (user_id, prompt_id, response_text, display_order, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?)'\r\n            )\r\n                .bind(userId, prompt.prompt_id, prompt.response_text, prompt.display_order, now, now)\r\n                .run()\r\n        }\r\n\r\n        logger.info('prompts_saved', undefined, { userId, count: prompts.length });\r\n        return { success: true, message: 'Prompts saved successfully' }\r\n    } catch (error) {\r\n        if (error instanceof z.ZodError) throw new ValidationError(error.errors[0].message);\r\n        if (error instanceof AppError) throw error;\r\n        throw new AppError('Save prompts failed', 500, 'SAVE_PROMPTS_ERROR', error);\r\n    }\r\n}\r\n\r\n// GET /api/user/:userId/prompts - Get user's responses\r\nexport async function getUserPrompts(env: Env, userId: string): Promise<UserPromptResponse[]> {\r\n    try {\r\n        const results = await env.DB.prepare(\r\n            `SELECT \r\n          upr.user_id,\r\n          upr.prompt_id,\r\n          pp.prompt_text,\r\n          upr.response_text,\r\n          upr.display_order,\r\n          upr.created_at,\r\n          upr.updated_at\r\n        FROM UserPromptResponses upr\r\n        JOIN ProfilePrompts pp ON upr.prompt_id = pp.id\r\n        WHERE upr.user_id = ?\r\n        ORDER BY upr.display_order ASC`\r\n        )\r\n            .bind(userId)\r\n            .all()\r\n\r\n        return results.results as any[]\r\n    } catch (e: any) {\r\n        throw new AppError('Failed to fetch user prompts', 500, 'FETCH_USER_PROMPTS_ERROR', e);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\proximity.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1744,1747],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1744,1747],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2826,2829],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2826,2829],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":125,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4027,4030],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4027,4030],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":220,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7213,7216],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7213,7216],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":255,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8575,8578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8575,8578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":287,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":287,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10161,10164],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10161,10164],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Proximity Alerts - Live Location Meetup System\r\n// Real-time meetup triggers when matched users are nearby\r\n\r\nimport { Env } from './index'\r\nimport { z } from 'zod';\r\nimport { AuthenticationError, ValidationError, AppError, NotFoundError } from './errors';\r\nimport { logger } from './logger';\r\nimport { verifyAuth } from './auth';\r\n\r\n// Zod Schemas\r\nconst EnableProximitySchema = z.object({\r\n    enabled: z.boolean(),\r\n});\r\n\r\nconst UpdateLocationSchema = z.object({\r\n    lat: z.number().min(-90).max(90),\r\n    long: z.number().min(-180).max(180),\r\n});\r\n\r\nconst RespondAlertSchema = z.object({\r\n    alert_id: z.string().uuid(),\r\n    response: z.enum(['accepted', 'declined']),\r\n});\r\n\r\nexport interface ProximityAlert {\r\n    id: string\r\n    match_name: string\r\n    match_photo: string\r\n    distance_meters: number\r\n    venue_name: string\r\n    venue_address: string\r\n    venue_type: string\r\n    expires_at: number\r\n}\r\n\r\n// POST /api/proximity/enable - Opt-in to proximity tracking\r\nexport async function enableProximity(\r\n    env: Env,\r\n    userId: string,\r\n    enabled: boolean\r\n): Promise<{ success: boolean; message: string }> {\r\n    try {\r\n        const now = Math.floor(Date.now() / 1000)\r\n\r\n        await env.DB.prepare(\r\n            `INSERT INTO ProximitySettings (user_id, enabled, last_updated) \r\n       VALUES (?, ?, ?)\r\n       ON CONFLICT(user_id) \r\n       DO UPDATE SET enabled = ?, last_updated = ?`\r\n        )\r\n            .bind(userId, enabled, now, enabled, now)\r\n            .run()\r\n\r\n        logger.info('proximity_toggled', undefined, { userId, enabled });\r\n        return {\r\n            success: true,\r\n            message: enabled ? 'Proximity alerts enabled' : 'Proximity alerts disabled',\r\n        }\r\n    } catch (error: any) {\r\n        throw new AppError('Failed to enable/disable proximity', 500, 'PROXIMITY_UPDATE_FAILED', error);\r\n    }\r\n}\r\n\r\n// POST /api/proximity/update-location - Update current location\r\nexport async function updateLocation(\r\n    env: Env,\r\n    userId: string,\r\n    lat: number,\r\n    long: number\r\n): Promise<{ success: boolean; nearby_matches?: ProximityAlert[] }> {\r\n    const now = Math.floor(Date.now() / 1000)\r\n\r\n    try {\r\n        // Update user's location\r\n        await env.DB.prepare(\r\n            'UPDATE ProximitySettings SET current_lat = ?, current_long = ?, last_updated = ? WHERE user_id = ? AND enabled = TRUE'\r\n        )\r\n            .bind(lat, long, now, userId)\r\n            .run()\r\n\r\n        // Find nearby matched users\r\n        const nearbyMatches = await findNearbyMatches(env, userId, lat, long)\r\n\r\n        if (nearbyMatches.length > 0) {\r\n            const alerts = await createProximityAlerts(env, userId, nearbyMatches)\r\n            return { success: true, nearby_matches: alerts }\r\n        }\r\n\r\n        return { success: true }\r\n    } catch (error: any) {\r\n        throw new AppError('Failed to update location', 500, 'LOCATION_UPDATE_FAILED', error);\r\n    }\r\n}\r\n\r\nasync function findNearbyMatches(\r\n    env: Env,\r\n    userId: string,\r\n    userLat: number,\r\n    userLong: number\r\n): Promise<Array<{ user_id: string; distance: number; lat: number; long: number }>> {\r\n    const matches = await env.DB.prepare(\r\n        `SELECT DISTINCT \r\n       CASE \r\n         WHEN m.user_a_id = ? THEN m.user_b_id \r\n         ELSE m.user_a_id \r\n       END as match_id,\r\n       ps.current_lat,\r\n       ps.current_long\r\n     FROM Matches m\r\n     JOIN ProximitySettings ps ON (\r\n       (m.user_a_id = ? AND ps.user_id = m.user_b_id) OR\r\n       (m.user_b_id = ? AND ps.user_id = m.user_a_id)\r\n     )\r\n     WHERE (m.user_a_id = ? OR m.user_b_id = ?)\r\n     AND ps.enabled = TRUE\r\n     AND ps.current_lat IS NOT NULL\r\n     AND ps.current_long IS NOT NULL\r\n     AND ps.last_updated > ?`\r\n    )\r\n        .bind(userId, userId, userId, userId, userId, Math.floor(Date.now() / 1000) - 3600) // Within last hour\r\n        .all()\r\n\r\n    const nearby: Array<{ user_id: string; distance: number; lat: number; long: number }> = []\r\n\r\n    for (const match of (matches.results || []) as any[]) {\r\n        const distance = calculateDistance(userLat, userLong, match.current_lat, match.current_long)\r\n        if (distance <= 500) {\r\n            nearby.push({\r\n                user_id: match.match_id,\r\n                distance: Math.round(distance),\r\n                lat: match.current_lat,\r\n                long: match.current_long,\r\n            })\r\n        }\r\n    }\r\n\r\n    return nearby\r\n}\r\n\r\nasync function createProximityAlerts(\r\n    env: Env,\r\n    userId: string,\r\n    nearbyMatches: Array<{ user_id: string; distance: number; lat: number; long: number }>\r\n): Promise<ProximityAlert[]> {\r\n    const now = Math.floor(Date.now() / 1000)\r\n    const expiresAt = now + 1800\r\n\r\n    const alerts: ProximityAlert[] = []\r\n\r\n    for (const match of nearbyMatches) {\r\n        const matchUser = await env.DB.prepare('SELECT name, main_photo_url FROM Users WHERE id = ?')\r\n            .bind(match.user_id)\r\n            .first()\r\n\r\n        if (!matchUser) continue\r\n\r\n        const venue = await findNearbyVenue(match.lat, match.long)\r\n\r\n        const alertId = crypto.randomUUID()\r\n        await env.DB.prepare(\r\n            `INSERT INTO ProximityAlerts \r\n       (id, user_a_id, user_b_id, distance_meters, venue_name, venue_address, venue_type, status, created_at, expires_at) \r\n       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\r\n        )\r\n            .bind(\r\n                alertId,\r\n                userId,\r\n                match.user_id,\r\n                match.distance,\r\n                venue.name,\r\n                venue.address,\r\n                venue.type,\r\n                'sent',\r\n                now,\r\n                expiresAt\r\n            )\r\n            .run()\r\n\r\n        const alert = {\r\n            id: alertId,\r\n            match_name: matchUser.name as string,\r\n            match_photo: matchUser.main_photo_url as string,\r\n            distance_meters: match.distance,\r\n            venue_name: venue.name,\r\n            venue_address: venue.address,\r\n            venue_type: venue.type,\r\n            expires_at: expiresAt,\r\n        };\r\n        alerts.push(alert)\r\n        logger.info('proximity_alert_created', undefined, { alertId, userId, matchId: match.user_id });\r\n    }\r\n\r\n    return alerts\r\n}\r\n\r\nfunction calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\r\n    const R = 6371e3\r\n    const 1 = (lat1 * Math.PI) / 180\r\n    const 2 = (lat2 * Math.PI) / 180\r\n    const  = ((lat2 - lat1) * Math.PI) / 180\r\n    const  = ((lon2 - lon1) * Math.PI) / 180\r\n\r\n    const a =\r\n        Math.sin( / 2) * Math.sin( / 2) +\r\n        Math.cos(1) * Math.cos(2) * Math.sin( / 2) * Math.sin( / 2)\r\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\r\n\r\n    return R * c\r\n}\r\n\r\nasync function findNearbyVenue(lat: number, long: number): Promise<{\r\n    name: string\r\n    address: string\r\n    type: string\r\n}> {\r\n    try {\r\n        // Query Overpass API for cafes or restaurants within 500m\r\n        const query = `[out:json];node(around:500,${lat},${long})[amenity~\"cafe|restaurant\"];out 1;`;\r\n        const response = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);\r\n        const data: any = await response.json();\r\n\r\n        if (data.elements && data.elements.length > 0) {\r\n            const venue = data.elements[0];\r\n            return {\r\n                name: venue.tags.name || 'Local Venue',\r\n                address: venue.tags['addr:street'] ? `${venue.tags['addr:street']}, ${venue.tags['addr:housenumber'] || ''}` : 'Nearby location',\r\n                type: venue.tags.amenity || 'social_spot',\r\n            };\r\n        }\r\n    } catch (e) {\r\n        logger.error('venue_search_failed', 'Overpass API search failed', { error: e });\r\n    }\r\n\r\n    return {\r\n        name: 'Vibrant Social Hub',\r\n        address: `${lat.toFixed(4)}, ${long.toFixed(4)}`,\r\n        type: 'elite_spot',\r\n    };\r\n}\r\n\r\n// POST /api/proximity/respond - Accept/decline meetup\r\nexport async function respondToProximityAlert(\r\n    env: Env,\r\n    alertId: string,\r\n    userId: string,\r\n    response: 'accepted' | 'declined'\r\n): Promise<{ success: boolean; message: string }> {\r\n    try {\r\n        await env.DB.prepare('UPDATE ProximityAlerts SET status = ? WHERE id = ? AND user_b_id = ?')\r\n            .bind(response, alertId, userId)\r\n            .run()\r\n\r\n        logger.info('proximity_response', undefined, { alertId, userId, response });\r\n        return { success: true, message: response === 'accepted' ? 'Meetup confirmed!' : 'Declined' }\r\n    } catch (error: any) {\r\n        throw new AppError('Failed to respond to proximity alert', 500, 'PROXIMITY_RESPOND_FAILED', error);\r\n    }\r\n}\r\n\r\nexport async function handleProximity(request: Request, env: Env): Promise<Response> {\r\n    const userId = await verifyAuth(request, env);\r\n    if (!userId) throw new AuthenticationError();\r\n\r\n    const url = new URL(request.url);\r\n    const path = url.pathname;\r\n    const method = request.method;\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    try {\r\n        if (path === '/v2/proximity/enable' && method === 'POST') {\r\n            const body = EnableProximitySchema.parse(await request.json());\r\n            const result = await enableProximity(env, userId, body.enabled);\r\n            return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n        }\r\n\r\n        if (path === '/v2/proximity/update' && method === 'POST') {\r\n            const body = UpdateLocationSchema.parse(await request.json());\r\n            const result = await updateLocation(env, userId, body.lat, body.long);\r\n            return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n        }\r\n\r\n        if (path === '/v2/proximity/respond' && method === 'POST') {\r\n            const body = RespondAlertSchema.parse(await request.json());\r\n            const result = await respondToProximityAlert(env, body.alert_id, userId, body.response);\r\n            return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n        }\r\n    } catch (e: any) {\r\n        if (e instanceof z.ZodError) throw new ValidationError(e.errors[0].message);\r\n        throw e;\r\n    }\r\n\r\n    throw new NotFoundError(\"Proximity route\");\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\ratelimit.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'key' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":33,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":33,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Rate Limiting & Anti-Spam\r\n// Cloudflare Workers rate limiting implementation\r\n\r\nimport { Env } from './index'\r\n\r\ninterface RateLimitConfig {\r\n    maxRequests: number\r\n    windowSeconds: number\r\n}\r\n\r\nconst RATE_LIMITS: Record<string, RateLimitConfig> = {\r\n    'swipe': { maxRequests: 100, windowSeconds: 86400 }, // 100 swipes per day\r\n    'message': { maxRequests: 50, windowSeconds: 86400 }, // 50 messages per day (free tier)\r\n    'signup': { maxRequests: 3, windowSeconds: 3600 }, // 3 signups per hour per IP\r\n    'api': { maxRequests: 100, windowSeconds: 60 }, // 100 API calls per minute\r\n}\r\n\r\nexport async function checkRateLimit(\r\n    env: Env,\r\n    userId: string,\r\n    action: keyof typeof RATE_LIMITS,\r\n    isPremium: boolean = false\r\n): Promise<{ allowed: boolean; remaining: number; resetAt: number }> {\r\n    const config = RATE_LIMITS[action]\r\n\r\n    // Premium users get unlimited swipes and messages\r\n    if (isPremium && (action === 'swipe' || action === 'message')) {\r\n        return { allowed: true, remaining: 999, resetAt: 0 }\r\n    }\r\n\r\n    const now = Math.floor(Date.now() / 1000)\r\n    const windowStart = now - config.windowSeconds\r\n    const key = `ratelimit:${action}:${userId}`\r\n\r\n    try {\r\n        // Get current count from D1\r\n        const result = await env.DB.prepare(\r\n            'SELECT COUNT(*) as count FROM RateLimits WHERE user_id = ? AND action = ? AND timestamp > ?'\r\n        )\r\n            .bind(userId, action, windowStart)\r\n            .first()\r\n\r\n        const currentCount = (result?.count as number) || 0\r\n\r\n        if (currentCount >= config.maxRequests) {\r\n            const resetAt = windowStart + config.windowSeconds\r\n            return { allowed: false, remaining: 0, resetAt }\r\n        }\r\n\r\n        // Log this action\r\n        await env.DB.prepare(\r\n            'INSERT INTO RateLimits (user_id, action, timestamp) VALUES (?, ?, ?)'\r\n        )\r\n            .bind(userId, action, now)\r\n            .run()\r\n\r\n        const remaining = config.maxRequests - currentCount - 1\r\n        const resetAt = now + config.windowSeconds\r\n\r\n        return { allowed: true, remaining, resetAt }\r\n    } catch (error) {\r\n        console.error('Rate limit check failed:', error)\r\n        // Fail open - allow the request\r\n        return { allowed: true, remaining: config.maxRequests, resetAt: now + config.windowSeconds }\r\n    }\r\n}\r\n\r\n// Cleanup old rate limit entries (run periodically)\r\nexport async function cleanupRateLimits(env: Env): Promise<void> {\r\n    const cutoff = Math.floor(Date.now() / 1000) - 86400 // 24 hours ago\r\n    await env.DB.prepare('DELETE FROM RateLimits WHERE timestamp < ?')\r\n        .bind(cutoff)\r\n        .run()\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\recovery.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ValidationError' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":25,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ValidationError"},"fix":{"range":[135,151],"text":""},"desc":"Remove unused variable \"ValidationError\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'NotFoundError' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":50,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"NotFoundError"},"fix":{"range":[160,175],"text":""},"desc":"Remove unused variable \"NotFoundError\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used. Allowed unused caught errors must match /^_/u.","line":88,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":88,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":95,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2959,2962],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2959,2962],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":132,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4878,4881],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4878,4881],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":179,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6631,6634],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6631,6634],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":218,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":218,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7975,7978],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7975,7978],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":245,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":245,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9208,9211],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9208,9211],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Account Recovery\r\n// Password reset and account recovery flows\r\n\r\nimport { Env } from './index'\r\nimport { z } from 'zod';\r\nimport { ValidationError, AppError, NotFoundError } from './errors';\r\nimport { logger } from './logger';\r\n\r\n// Zod Schemas\r\nconst RequestResetSchema = z.object({\r\n    email: z.string().email(),\r\n});\r\n\r\nconst ResetPasswordSchema = z.object({\r\n    token: z.string().uuid(),\r\n    new_password: z.string().min(8).max(100),\r\n});\r\n\r\n// PBKDF2 Password Hashing (Cloudflare Workers compatible)\r\nconst PBKDF2_ITERATIONS = 100000;\r\nconst SALT_LENGTH = 16;\r\nconst KEY_LENGTH = 32;\r\n\r\nasync function hashPassword(password: string): Promise<string> {\r\n    const salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH));\r\n    const encoder = new TextEncoder();\r\n    const passwordKey = await crypto.subtle.importKey(\r\n        'raw',\r\n        encoder.encode(password),\r\n        'PBKDF2',\r\n        false,\r\n        ['deriveBits']\r\n    );\r\n\r\n    const hash = await crypto.subtle.deriveBits(\r\n        {\r\n            name: 'PBKDF2',\r\n            salt: salt,\r\n            iterations: PBKDF2_ITERATIONS,\r\n            hash: 'SHA-256',\r\n        },\r\n        passwordKey,\r\n        KEY_LENGTH * 8\r\n    );\r\n\r\n    // Format: iterations$salt$hash (all base64)\r\n    const saltB64 = btoa(String.fromCharCode(...salt));\r\n    const hashB64 = btoa(String.fromCharCode(...new Uint8Array(hash)));\r\n    return `${PBKDF2_ITERATIONS}$${saltB64}$${hashB64}`;\r\n}\r\n\r\nexport async function verifyPassword(password: string, storedHash: string): Promise<boolean> {\r\n    try {\r\n        const [iterations, saltB64, hashB64] = storedHash.split('$');\r\n        if (!iterations || !saltB64 || !hashB64) return false;\r\n\r\n        const salt = Uint8Array.from(atob(saltB64), c => c.charCodeAt(0));\r\n        const expectedHash = Uint8Array.from(atob(hashB64), c => c.charCodeAt(0));\r\n\r\n        const encoder = new TextEncoder();\r\n        const passwordKey = await crypto.subtle.importKey(\r\n            'raw',\r\n            encoder.encode(password),\r\n            'PBKDF2',\r\n            false,\r\n            ['deriveBits']\r\n        );\r\n\r\n        const computedHash = await crypto.subtle.deriveBits(\r\n            {\r\n                name: 'PBKDF2',\r\n                salt: salt,\r\n                iterations: parseInt(iterations),\r\n                hash: 'SHA-256',\r\n            },\r\n            passwordKey,\r\n            KEY_LENGTH * 8\r\n        );\r\n\r\n        const computedArray = new Uint8Array(computedHash);\r\n        if (computedArray.length !== expectedHash.length) return false;\r\n\r\n        let result = 0;\r\n        for (let i = 0; i < computedArray.length; i++) {\r\n            result |= computedArray[i] ^ expectedHash[i];\r\n        }\r\n        return result === 0;\r\n    } catch (e) {\r\n        return false;\r\n    }\r\n}\r\n\r\n// Send password reset email via Resend\r\nasync function sendPasswordResetEmail(env: Env, email: string, resetToken: string): Promise<boolean> {\r\n    const apiKey = (env as any).RESEND_API_KEY;\r\n\r\n    if (!apiKey) {\r\n        logger.warn('password_reset_email_skipped', 'RESEND_API_KEY not configured', { email });\r\n        return false;\r\n    }\r\n\r\n    const resetLink = `https://love-vibes-frontend.pages.dev/reset-password?token=${resetToken}`;\r\n\r\n    try {\r\n        const response = await fetch('https://api.resend.com/emails', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${apiKey}`,\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify({\r\n                from: 'Love Vibes <noreply@lovevibes.app>',\r\n                to: [email],\r\n                subject: 'Reset Your Love Vibes Password',\r\n                html: `\r\n                    <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\r\n                        <h1 style=\"color: #D4AF37;\">Love Vibes</h1>\r\n                        <h2>Password Reset Request</h2>\r\n                        <p>We received a request to reset your password. Click the button below to create a new password:</p>\r\n                        <a href=\"${resetLink}\" style=\"display: inline-block; background-color: #D4AF37; color: #1A0814; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold; margin: 16px 0;\">\r\n                            Reset Password\r\n                        </a>\r\n                        <p style=\"color: #666; font-size: 14px;\">This link will expire in 1 hour.</p>\r\n                        <p style=\"color: #666; font-size: 14px;\">If you didn't request this, you can safely ignore this email.</p>\r\n                        <hr style=\"border: 1px solid #eee; margin: 24px 0;\">\r\n                        <p style=\"color: #999; font-size: 12px;\">Love Vibes - Elite connections, your way</p>\r\n                    </div>\r\n                `\r\n            })\r\n        });\r\n\r\n        const result: any = await response.json();\r\n\r\n        if (!response.ok) {\r\n            logger.error('password_reset_email_failed', result, { email });\r\n            return false;\r\n        }\r\n\r\n        logger.info('password_reset_email_sent', undefined, { email, messageId: result.id });\r\n        return true;\r\n    } catch (e) {\r\n        logger.error('password_reset_email_error', e, { email });\r\n        return false;\r\n    }\r\n}\r\n\r\nexport async function requestPasswordReset(env: Env, email: string): Promise<{ success: boolean; message: string }> {\r\n    try {\r\n        // Check if user exists\r\n        const user = await env.DB.prepare('SELECT id, email FROM Users WHERE email = ?')\r\n            .bind(email)\r\n            .first()\r\n\r\n        if (!user) {\r\n            // Don't reveal if email exists\r\n            return { success: true, message: 'If an account exists, a reset link has been sent' }\r\n        }\r\n\r\n        // Generate reset token (valid for 1 hour)\r\n        const resetToken = crypto.randomUUID()\r\n        const expiresAt = Math.floor(Date.now() / 1000) + 3600\r\n\r\n        // Delete any existing tokens for this user\r\n        await env.DB.prepare('DELETE FROM PasswordResetTokens WHERE user_id = ?')\r\n            .bind(user.id)\r\n            .run()\r\n\r\n        // Store reset token\r\n        await env.DB.prepare(\r\n            'INSERT INTO PasswordResetTokens (user_id, token, expires_at, created_at) VALUES (?, ?, ?, ?)'\r\n        )\r\n            .bind(user.id, resetToken, expiresAt, Math.floor(Date.now() / 1000))\r\n            .run()\r\n\r\n        // Send email with reset link\r\n        await sendPasswordResetEmail(env, email, resetToken);\r\n\r\n        return { success: true, message: 'If an account exists, a reset link has been sent' }\r\n    } catch (error: any) {\r\n        throw new AppError('Password reset request failed', 500, 'RESET_REQUEST_FAILED', error);\r\n    }\r\n}\r\n\r\nexport async function resetPassword(\r\n    env: Env,\r\n    token: string,\r\n    newPassword: string\r\n): Promise<{ success: boolean; message: string }> {\r\n    try {\r\n        const now = Math.floor(Date.now() / 1000)\r\n\r\n        // Verify token\r\n        const resetRecord = await env.DB.prepare(\r\n            'SELECT user_id, expires_at FROM PasswordResetTokens WHERE token = ? AND expires_at > ?'\r\n        )\r\n            .bind(token, now)\r\n            .first()\r\n\r\n        if (!resetRecord) {\r\n            throw new AppError('Invalid or expired reset token', 400, 'INVALID_TOKEN');\r\n        }\r\n\r\n        // Hash new password with PBKDF2\r\n        const passwordHash = await hashPassword(newPassword)\r\n\r\n        // Update password\r\n        await env.DB.prepare('UPDATE Users SET password_hash = ? WHERE id = ?')\r\n            .bind(passwordHash, resetRecord.user_id)\r\n            .run()\r\n\r\n        // Delete used token\r\n        await env.DB.prepare('DELETE FROM PasswordResetTokens WHERE token = ?')\r\n            .bind(token)\r\n            .run()\r\n\r\n        logger.info('password_reset_success', undefined, { userId: resetRecord.user_id });\r\n        return { success: true, message: 'Password reset successfully' }\r\n    } catch (error: any) {\r\n        if (error instanceof AppError) throw error;\r\n        throw new AppError('Failed to reset password', 500, 'RESET_FAILED', error);\r\n    }\r\n}\r\n\r\n// HTTP Handler for recovery routes\r\nexport async function handleRecovery(request: Request, env: Env): Promise<Response> {\r\n    const url = new URL(request.url);\r\n    const path = url.pathname;\r\n    const method = request.method;\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    try {\r\n        // POST /v2/recovery/request - Request password reset\r\n        if (path.endsWith('/request') && method === 'POST') {\r\n            const body = RequestResetSchema.parse(await request.json());\r\n            const result = await requestPasswordReset(env, body.email);\r\n            return new Response(JSON.stringify(result), { headers: jsonHeaders });\r\n        }\r\n\r\n        // POST /v2/recovery/reset - Reset password with token\r\n        if (path.endsWith('/reset') && method === 'POST') {\r\n            const body = ResetPasswordSchema.parse(await request.json());\r\n            const result = await resetPassword(env, body.token, body.new_password);\r\n            return new Response(JSON.stringify(result), { headers: jsonHeaders });\r\n        }\r\n    } catch (e: any) {\r\n        if (e instanceof z.ZodError) {\r\n            throw new AppError(e.errors[0].message, 400, 'VALIDATION_ERROR');\r\n        }\r\n        throw e;\r\n    }\r\n\r\n    throw new AppError('Method not allowed', 405, 'METHOD_NOT_ALLOWED');\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\referrals.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'z' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":11,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"z"},"fix":{"range":[118,142],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ValidationError' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":25,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ValidationError"},"fix":{"range":[153,169],"text":""},"desc":"Remove unused variable \"ValidationError\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":113,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3915,3918],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3915,3918],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":119,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4084,4087],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4084,4087],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Referral Tracking System\r\n// Track referrals and reward users with Scenario Keys\r\n\r\nimport { Env } from './index'\r\nimport { z } from 'zod';\r\nimport { ValidationError, AppError, NotFoundError } from './errors';\r\nimport { logger } from './logger';\r\n\r\nexport interface ReferralStats {\r\n    referral_code: string\r\n    total_referrals: number\r\n    successful_signups: number\r\n    available_keys: number\r\n    referrals: Array<{\r\n        name: string\r\n        joined_at: number\r\n        status: 'signed_up' | 'active' | 'premium'\r\n    }>\r\n}\r\n\r\n// Generate unique referral code for user\r\nexport async function generateReferralCode(env: Env, userId: string): Promise<string> {\r\n    const user = await env.DB.prepare('SELECT name FROM Users WHERE id = ?')\r\n        .bind(userId)\r\n        .first()\r\n\r\n    if (!user) throw new NotFoundError('User')\r\n\r\n    const firstName = (user.name as string || 'USER').split(' ')[0].toUpperCase()\r\n    const randomChars = Math.random().toString(36).substring(2, 6).toUpperCase()\r\n    const code = `${firstName}${randomChars}`\r\n\r\n    await env.DB.prepare('UPDATE Users SET referral_code = ? WHERE id = ?')\r\n        .bind(code, userId)\r\n        .run()\r\n\r\n    return code\r\n}\r\n\r\n// Track referral signup\r\nexport async function trackReferral(\r\n    env: Env,\r\n    referralCode: string,\r\n    newUserId: string\r\n): Promise<{ success: boolean; reward?: number }> {\r\n    try {\r\n        const referrer = await env.DB.prepare('SELECT id FROM Users WHERE referral_code = ?')\r\n            .bind(referralCode)\r\n            .first()\r\n\r\n        if (!referrer) return { success: false }\r\n\r\n        const now = Math.floor(Date.now() / 1000)\r\n\r\n        // Log referral\r\n        await env.DB.prepare(\r\n            'INSERT INTO Referrals (referrer_id, referred_id, status, created_at) VALUES (?, ?, ?, ?)'\r\n        )\r\n            .bind(referrer.id, newUserId, 'signed_up', now)\r\n            .run()\r\n\r\n        // Reward referrer with 3 Scenario Keys\r\n        const keysReward = 3\r\n        await env.DB.prepare('UPDATE Users SET scenario_keys = scenario_keys + ? WHERE id = ?')\r\n            .bind(keysReward, referrer.id)\r\n            .run()\r\n\r\n        logger.info('referral_tracked', undefined, { referrerId: referrer.id, newUserId, reward: keysReward });\r\n        return { success: true, reward: keysReward }\r\n    } catch (error) {\r\n        logger.error('referral_tracking_failed', error);\r\n        return { success: false }\r\n    }\r\n}\r\n\r\nexport async function getReferralStats(env: Env, userId: string): Promise<ReferralStats> {\r\n    try {\r\n        const user = await env.DB.prepare('SELECT referral_code, scenario_keys FROM Users WHERE id = ?')\r\n            .bind(userId)\r\n            .first()\r\n\r\n        if (!user) throw new NotFoundError('User');\r\n\r\n        let referralCode = user.referral_code as string;\r\n        if (!referralCode) {\r\n            referralCode = await generateReferralCode(env, userId);\r\n        }\r\n\r\n        const stats = await env.DB.prepare(\r\n            `SELECT \r\n          COUNT(*) as total,\r\n          SUM(CASE WHEN status = 'active' OR status = 'premium' THEN 1 ELSE 0 END) as successful\r\n        FROM Referrals \r\n        WHERE referrer_id = ?`\r\n        ).bind(userId).first() || { total: 0, successful: 0 };\r\n\r\n        const referralsResult = await env.DB.prepare(\r\n            `SELECT u.name, r.created_at, r.status\r\n         FROM Referrals r\r\n         JOIN Users u ON r.referred_id = u.id\r\n         WHERE r.referrer_id = ?\r\n         ORDER BY r.created_at DESC\r\n         LIMIT 50`\r\n        ).bind(userId).all();\r\n\r\n        const referralsList = referralsResult.results || [];\r\n\r\n        return {\r\n            referral_code: referralCode,\r\n            total_referrals: (stats.total as number) || 0,\r\n            successful_signups: (stats.successful as number) || 0,\r\n            available_keys: (user.scenario_keys as number) || 0,\r\n            referrals: referralsList.map((r: any) => ({\r\n                name: r.name,\r\n                joined_at: r.created_at,\r\n                status: r.status,\r\n            })),\r\n        }\r\n    } catch (error: any) {\r\n        if (error instanceof AppError) throw error;\r\n        throw new AppError('Failed to fetch referral stats', 500, 'REFERRAL_STATS_ERROR', error);\r\n    }\r\n}\r\n\r\n// Unlock a scenario (spend a key)\r\nexport async function unlockScenario(env: Env, userId: string, scenarioType: 'intimate' | 'mystical'): Promise<{ success: boolean, keysRemaining: number }> {\r\n    const user = await env.DB.prepare('SELECT scenario_keys FROM Users WHERE id = ?')\r\n        .bind(userId)\r\n        .first()\r\n\r\n    if (!user || (user.scenario_keys as number) < 1) {\r\n        throw new AppError(\"Insufficient Scenario Keys\", 402, 'INSUFFICIENT_KEYS');\r\n    }\r\n\r\n    const newKeys = (user.scenario_keys as number) - 1;\r\n\r\n    await env.DB.prepare('UPDATE Users SET scenario_keys = ? WHERE id = ?')\r\n        .bind(newKeys, userId)\r\n        .run()\r\n\r\n    logger.info('scenario_unlocked', undefined, { userId, scenarioType, keysRemaining: newKeys });\r\n\r\n    return {\r\n        success: true,\r\n        keysRemaining: newKeys\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\rewind.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ValidationError' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":46,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ValidationError"},"fix":{"range":[152,169],"text":""},"desc":"Remove unused variable \"ValidationError\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1213,1216],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1213,1216],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3300,3303],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3300,3303],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Undo/Rewind Feature\r\n// Allow users to undo their last swipe\r\n\r\nimport { Env } from './index'\r\nimport { z } from 'zod';\r\nimport { AuthenticationError, ValidationError, AppError } from './errors';\r\nimport { logger } from './logger';\r\nimport { verifyAuth } from './auth';\r\n\r\n// Zod Schema\r\nconst RewindSchema = z.object({\r\n    is_premium: z.boolean().default(false),\r\n});\r\n\r\ninterface SwipeHistory {\r\n    actor_id: string\r\n    target_id: string\r\n    type: string\r\n    timestamp: number\r\n}\r\n\r\n// Store last 10 swipes in memory per user session\r\nconst swipeHistory = new Map<string, SwipeHistory[]>()\r\n\r\nexport function recordSwipe(userId: string, targetId: string, type: string): void {\r\n    if (!swipeHistory.has(userId)) {\r\n        swipeHistory.set(userId, [])\r\n    }\r\n\r\n    const history = swipeHistory.get(userId)!\r\n    history.unshift({\r\n        actor_id: userId,\r\n        target_id: targetId,\r\n        type,\r\n        timestamp: Date.now(),\r\n    })\r\n\r\n    // Keep only last 10 swipes\r\n    if (history.length > 10) {\r\n        history.pop()\r\n    }\r\n}\r\n\r\nexport async function undoLastSwipe(\r\n    env: Env,\r\n    userId: string,\r\n    isPremium: boolean\r\n): Promise<{ success: boolean; message: string; profile?: any }> {\r\n    const history = swipeHistory.get(userId)\r\n\r\n    if (!history || history.length === 0) {\r\n        throw new AppError('No swipes to undo', 400, 'NO_SWIPES_TO_UNDO');\r\n    }\r\n\r\n    // Check rewind limit for free users\r\n    if (!isPremium) {\r\n        const today = new Date().toDateString()\r\n\r\n        const rewindCount = await env.DB.prepare(\r\n            'SELECT COUNT(*) as count FROM RewindHistory WHERE user_id = ? AND date = ?'\r\n        )\r\n            .bind(userId, today)\r\n            .first()\r\n\r\n        if ((rewindCount?.count as number) >= 1) {\r\n            throw new AppError('Free users get 1 rewind per day. Upgrade for unlimited!', 402, 'REWIND_LIMIT_REACHED');\r\n        }\r\n    }\r\n\r\n    try {\r\n        const lastSwipe = history.shift()!\r\n\r\n        // Delete the swipe from database\r\n        await env.DB.prepare('DELETE FROM Swipes WHERE actor_id = ? AND target_id = ?')\r\n            .bind(lastSwipe.actor_id, lastSwipe.target_id)\r\n            .run()\r\n\r\n        // If it was a match, delete the match too\r\n        if (lastSwipe.type === 'LIKE') {\r\n            await env.DB.prepare(\r\n                'DELETE FROM Matches WHERE (user_a_id = ? AND user_b_id = ?) OR (user_a_id = ? AND user_b_id = ?)'\r\n            )\r\n                .bind(userId, lastSwipe.target_id, lastSwipe.target_id, userId)\r\n                .run()\r\n        }\r\n\r\n        // Log rewind for free users\r\n        if (!isPremium) {\r\n            const today = new Date().toDateString()\r\n            await env.DB.prepare(\r\n                'INSERT INTO RewindHistory (user_id, date, timestamp) VALUES (?, ?, ?)'\r\n            )\r\n                .bind(userId, today, Math.floor(Date.now() / 1000))\r\n                .run()\r\n        }\r\n\r\n        // Get the profile to show again\r\n        const profile = await env.DB.prepare('SELECT * FROM Users WHERE id = ?')\r\n            .bind(lastSwipe.target_id)\r\n            .first()\r\n\r\n        logger.info('swipe_undone', undefined, { userId, targetId: lastSwipe.target_id });\r\n        return { success: true, message: 'Swipe undone', profile }\r\n    } catch (error: any) {\r\n        if (error instanceof AppError) throw error;\r\n        throw new AppError('Failed to undo swipe', 500, 'UNDO_FAILED', error);\r\n    }\r\n}\r\n\r\n// HTTP Handler for rewind routes\r\nexport async function handleRewind(request: Request, env: Env): Promise<Response> {\r\n    const userId = await verifyAuth(request, env);\r\n    if (!userId) throw new AuthenticationError();\r\n\r\n    const method = request.method;\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    if (method === 'POST') {\r\n        const body = RewindSchema.parse(await request.json());\r\n        const result = await undoLastSwipe(env, userId, body.is_premium);\r\n        return new Response(JSON.stringify(result), { headers: jsonHeaders });\r\n    }\r\n\r\n    throw new AppError('Method not allowed', 405, 'METHOD_NOT_ALLOWED');\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\safety.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1718,1721],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1718,1721],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2760,2763],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2760,2763],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Env } from './index';\r\nimport { verifyAuth } from './auth';\r\nimport { z } from 'zod';\r\nimport { ValidationError, AuthenticationError, AppError } from './errors';\r\nimport { logger } from './logger';\r\n\r\nconst ReportSchema = z.object({\r\n    reported_id: z.string().uuid(),\r\n    reason: z.string().min(1).max(100),\r\n    details: z.string().max(500).optional(),\r\n});\r\n\r\nconst BlockSchema = z.object({\r\n    blocked_id: z.string().uuid(),\r\n});\r\n\r\nexport async function handleReportUser(request: Request, env: Env): Promise<Response> {\r\n    const userId = await verifyAuth(request, env);\r\n    if (!userId) throw new AuthenticationError();\r\n\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    try {\r\n        const body = ReportSchema.parse(await request.json());\r\n        const { reported_id, reason, details } = body;\r\n\r\n        const reportId = crypto.randomUUID();\r\n        const timestamp = Math.floor(Date.now() / 1000);\r\n\r\n        await env.DB.prepare(\r\n            `INSERT INTO Reports (id, reporter_id, reported_id, reason, details, timestamp, status) VALUES (?, ?, ?, ?, ?, ?, ?)`\r\n        ).bind(reportId, userId, reported_id, reason, details, timestamp, 'PENDING').run();\r\n\r\n        // Auto-Block on Report (Standard Safety Practice)\r\n        await env.DB.prepare(\r\n            `INSERT OR IGNORE INTO Blocks (blocker_id, blocked_id, timestamp) VALUES (?, ?, ?)`\r\n        ).bind(userId, reported_id, timestamp).run();\r\n\r\n        logger.info('user_reported', undefined, { userId, reportedId: reported_id, reason });\r\n\r\n        return new Response(JSON.stringify({ success: true, data: { message: 'Report received' } }), {\r\n            headers: jsonHeaders\r\n        });\r\n\r\n    } catch (e: any) {\r\n        if (e instanceof z.ZodError) throw new ValidationError(e.errors[0].message);\r\n        throw new AppError('Report failed', 500, 'REPORT_ERROR', e);\r\n    }\r\n}\r\n\r\nexport async function handleBlockUser(request: Request, env: Env): Promise<Response> {\r\n    const userId = await verifyAuth(request, env);\r\n    if (!userId) throw new AuthenticationError();\r\n\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    try {\r\n        const body = BlockSchema.parse(await request.json());\r\n        const { blocked_id } = body;\r\n\r\n        const timestamp = Math.floor(Date.now() / 1000);\r\n        await env.DB.prepare(\r\n            `INSERT OR IGNORE INTO Blocks (blocker_id, blocked_id, timestamp) VALUES (?, ?, ?)`\r\n        ).bind(userId, blocked_id, timestamp).run();\r\n\r\n        logger.info('user_blocked', undefined, { userId, blockedId: blocked_id });\r\n\r\n        return new Response(JSON.stringify({ success: true, data: { message: 'User blocked' } }), {\r\n            headers: jsonHeaders\r\n        });\r\n    } catch (e: any) {\r\n        if (e instanceof z.ZodError) throw new ValidationError(e.errors[0].message);\r\n        throw new AppError('Block failed', 500, 'BLOCK_ERROR', e);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\success-stories.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1003,1006],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1003,1006],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2711,2714],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2711,2714],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Success Stories System\r\n// Public success stories and testimonials\r\n\r\nimport { Env } from './index'\r\nimport { z } from 'zod';\r\nimport { AuthenticationError, ValidationError, NotFoundError, AppError } from './errors';\r\nimport { logger } from './logger';\r\nimport { verifyAuth } from './auth';\r\n\r\n// Zod Schema\r\nconst SubmitStorySchema = z.object({\r\n    partner_id: z.string().uuid(),\r\n    story_text: z.string().min(50).max(2000),\r\n    relationship_length: z.string().min(1).max(50),\r\n});\r\n\r\nexport interface SuccessStory {\r\n    id: string\r\n    user_a_name: string\r\n    user_b_name: string\r\n    user_a_photo: string\r\n    user_b_photo: string\r\n    story_text: string\r\n    relationship_length: string // \"6 months\", \"1 year\", etc.\r\n    wedding_fund_contributed: boolean\r\n    is_featured: boolean\r\n    created_at: number\r\n    approved: boolean\r\n}\r\n\r\n// POST /api/success-stories/submit - Submit a success story\r\nexport async function submitSuccessStory(\r\n    env: Env,\r\n    userId: string,\r\n    storyRaw: any\r\n): Promise<{ success: boolean; message: string }> {\r\n    try {\r\n        const story = SubmitStorySchema.parse(storyRaw);\r\n        const now = Math.floor(Date.now() / 1000)\r\n        const storyId = crypto.randomUUID()\r\n\r\n        // Get user details\r\n        const user = await env.DB.prepare('SELECT name, main_photo_url FROM Users WHERE id = ?')\r\n            .bind(userId)\r\n            .first()\r\n\r\n        const partner = await env.DB.prepare('SELECT name, main_photo_url FROM Users WHERE id = ?')\r\n            .bind(story.partner_id)\r\n            .first()\r\n\r\n        if (!user) {\r\n            throw new NotFoundError('User not found for the submitting user.');\r\n        }\r\n        if (!partner) {\r\n            throw new NotFoundError('Partner not found.');\r\n        }\r\n\r\n        // Insert story (pending approval)\r\n        await env.DB.prepare(\r\n            `INSERT INTO SuccessStories \r\n      (id, user_a_id, user_b_id, user_a_name, user_b_name, user_a_photo, user_b_photo, \r\n       story_text, relationship_length, approved, created_at) \r\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\r\n        )\r\n            .bind(\r\n                storyId,\r\n                userId,\r\n                story.partner_id,\r\n                user.name,\r\n                partner.name,\r\n                user.main_photo_url,\r\n                partner.main_photo_url,\r\n                story.story_text,\r\n                story.relationship_length,\r\n                false,\r\n                now\r\n            )\r\n            .run()\r\n\r\n        logger.info('story_submitted', undefined, { userId, partnerId: story.partner_id, storyId });\r\n        return { success: true, message: 'Story submitted for review!' }\r\n    } catch (error: any) {\r\n        if (error instanceof z.ZodError) throw new ValidationError(error.errors[0].message);\r\n        if (error instanceof AppError) throw error;\r\n        throw new AppError('Failed to submit story', 500, 'STORY_SUBMISSION_FAILED', error);\r\n    }\r\n}\r\n\r\n// GET /api/success-stories - Get approved success stories\r\nexport async function getSuccessStories(env: Env, limit: number = 20): Promise<SuccessStory[]> {\r\n    const results = await env.DB.prepare(\r\n        `SELECT * FROM SuccessStories \r\n     WHERE approved = TRUE \r\n     ORDER BY is_featured DESC, created_at DESC \r\n     LIMIT ?`\r\n    )\r\n        .bind(limit)\r\n        .all()\r\n\r\n    return results.results as unknown as SuccessStory[]\r\n}\r\n\r\n// HTTP Handler for success stories routes\r\nexport async function handleSuccessStories(request: Request, env: Env): Promise<Response> {\r\n    const userId = await verifyAuth(request, env).catch(() => null); // Public GET, Auth POST\r\n\r\n    const url = new URL(request.url);\r\n    const method = request.method;\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    // GET /v2/success-stories - Get approved stories\r\n    if (method === 'GET') {\r\n        const limit = parseInt(url.searchParams.get('limit') || '20');\r\n        const stories = await getSuccessStories(env, limit);\r\n        return new Response(JSON.stringify({ success: true, data: stories }), {\r\n            headers: jsonHeaders\r\n        });\r\n    }\r\n\r\n    // POST /v2/success-stories - Submit a story\r\n    if (method === 'POST') {\r\n        if (!userId) throw new AuthenticationError();\r\n        const body = await request.json();\r\n        const result = await submitSuccessStory(env, userId, body);\r\n\r\n        return new Response(JSON.stringify(result), { headers: jsonHeaders });\r\n    }\r\n\r\n    throw new AppError('Method not allowed', 405, 'METHOD_NOT_ALLOWED');\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\swipe.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AppError' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":48,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":56,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"AppError"},"fix":{"range":[215,225],"text":""},"desc":"Remove unused variable \"AppError\"."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Swipe Module\r\n * Handles Likes, Passes, and Match Detection\r\n */\r\nimport { Env } from './index';\r\nimport { verifyAuth } from './auth';\r\nimport { z } from 'zod';\r\nimport { ValidationError, AuthenticationError, AppError } from './errors';\r\nimport { notifyNewMatch } from './notifications';\r\n\r\nconst SwipeSchema = z.object({\r\n    id: z.string().uuid(),\r\n});\r\n\r\nexport async function handleSwipe(request: Request, env: Env): Promise<Response> {\r\n    const userId = await verifyAuth(request, env); // Actor\r\n    if (!userId) throw new AuthenticationError();\r\n\r\n    const url = new URL(request.url);\r\n    const targetId = url.searchParams.get('id');\r\n    const type = url.pathname === '/like' ? 'LIKE' : 'PASS';\r\n\r\n    // Validate using Zod (even if from query params)\r\n    const validation = SwipeSchema.safeParse({ id: targetId });\r\n    if (!validation.success) {\r\n        throw new ValidationError(\"Missing or invalid target ID\");\r\n    }\r\n\r\n    // 1. Record the Swipe\r\n    const timestamp = Date.now();\r\n    await env.DB.prepare(\r\n        \"INSERT OR REPLACE INTO Swipes (actor_id, target_id, type, timestamp) VALUES (?, ?, ?, ?)\"\r\n    ).bind(userId, targetId, type, timestamp).run();\r\n\r\n    let matchData = null;\r\n\r\n    // 2. If LIKE, check for Mutual Match\r\n    if (type === 'LIKE') {\r\n        const { results } = await env.DB.prepare(\r\n            \"SELECT * FROM Swipes WHERE actor_id = ? AND target_id = ? AND type = 'LIKE'\"\r\n        ).bind(targetId, userId).all();\r\n\r\n        if (results.length > 0) {\r\n            // ITS A MATCH!\r\n            const matchId = crypto.randomUUID();\r\n\r\n            // Create Match Record\r\n            await env.DB.prepare(\r\n                \"INSERT INTO Matches (id, user_a_id, user_b_id, created_at) VALUES (?, ?, ?, ?)\"\r\n            ).bind(matchId, userId, targetId, timestamp).run();\r\n\r\n            // Create Chat Room Durable Object ID\r\n            const doId = env.CHAT_ROOM.newUniqueId();\r\n            await env.DB.prepare(\r\n                \"UPDATE Matches SET chat_room_do_id = ? WHERE id = ?\"\r\n            ).bind(doId.toString(), matchId).run();\r\n\r\n            // Get user names for notification\r\n            const [currentUser, targetUser] = await Promise.all([\r\n                env.DB.prepare(\"SELECT name FROM Users WHERE id = ?\").bind(userId).first(),\r\n                env.DB.prepare(\"SELECT name FROM Users WHERE id = ?\").bind(targetId).first()\r\n            ]);\r\n\r\n            // Send push notifications to both users\r\n            await Promise.all([\r\n                notifyNewMatch(env, userId, (targetUser?.name as string) || 'Someone'),\r\n                notifyNewMatch(env, targetId as string, (currentUser?.name as string) || 'Someone')\r\n            ]);\r\n\r\n            matchData = {\r\n                match_id: matchId,\r\n                is_match: true,\r\n                chat_room_id: doId.toString()\r\n            };\r\n        }\r\n    }\r\n\r\n    return new Response(JSON.stringify({\r\n        success: true,\r\n        data: {\r\n            swiped: true,\r\n            match: matchData\r\n        }\r\n    }), { headers: { 'Content-Type': 'application/json' } });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\user.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\vibe-windows.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'NotFoundError' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":58,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":71,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"NotFoundError"},"fix":{"range":[222,237],"text":""},"desc":"Remove unused variable \"NotFoundError\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1180,1183],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1180,1183],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2036,2039],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2036,2039],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2874,2877],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2874,2877],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":155,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5921,5924],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5921,5924],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Vibe Windows - Scheduled Matching System\r\n// Time-boxed matching creates scarcity and focused attention\r\n\r\nimport { Env } from './index'\r\nimport { z } from 'zod';\r\nimport { AuthenticationError, ValidationError, AppError, NotFoundError } from './errors';\r\nimport { logger } from './logger';\r\nimport { verifyAuth } from './auth';\r\n\r\n// Zod Schemas\r\nconst VibeWindowSchema = z.object({\r\n    day_of_week: z.number().int().min(0).max(6),\r\n    start_hour: z.number().int().min(0).max(23),\r\n});\r\n\r\nconst SetVibeWindowsSchema = z.object({\r\n    windows: z.array(VibeWindowSchema).max(2),\r\n});\r\n\r\nexport interface VibeWindow {\r\n    day_of_week: number\r\n    start_hour: number\r\n    duration_minutes: number\r\n    is_active: boolean\r\n}\r\n\r\nexport interface ActiveWindowInfo {\r\n    is_in_window: boolean\r\n    current_window?: VibeWindow\r\n    next_window?: { starts_in_seconds: number; day: string; time: string }\r\n    users_online_now: number\r\n}\r\n\r\nconst DAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\r\n\r\n// POST /api/vibe-windows/set - Set user's vibe windows\r\nexport async function setVibeWindows(\r\n    env: Env,\r\n    userId: string,\r\n    windowsRaw: any\r\n): Promise<{ success: boolean; message: string }> {\r\n    try {\r\n        const { windows } = SetVibeWindowsSchema.parse(windowsRaw);\r\n        const now = Math.floor(Date.now() / 1000)\r\n\r\n        // Delete existing windows\r\n        await env.DB.prepare('DELETE FROM VibeWindows WHERE user_id = ?').bind(userId).run()\r\n\r\n        // Insert new windows\r\n        for (const window of windows) {\r\n            await env.DB.prepare(\r\n                'INSERT INTO VibeWindows (user_id, day_of_week, start_hour, duration_minutes, is_active, created_at) VALUES (?, ?, ?, ?, ?, ?)'\r\n            ).bind(userId, window.day_of_week, window.start_hour, 60, true, now).run()\r\n        }\r\n\r\n        logger.info('vibe_windows_updated', undefined, { userId, count: windows.length });\r\n        return { success: true, message: 'Vibe windows updated!' }\r\n    } catch (error: any) {\r\n        if (error instanceof z.ZodError) throw new ValidationError(error.errors[0].message);\r\n        throw new AppError('Failed to set vibe windows', 500, 'VIBE_UPDATE_FAILED', error);\r\n    }\r\n}\r\n\r\n// GET /api/vibe-windows/status - Check if user is in active window\r\nexport async function getVibeWindowStatus(env: Env, userId: string): Promise<ActiveWindowInfo> {\r\n    const now = new Date()\r\n    const currentDay = now.getDay()\r\n    const currentHour = now.getHours()\r\n    const currentMinute = now.getMinutes()\r\n\r\n    const windows = await env.DB.prepare('SELECT * FROM VibeWindows WHERE user_id = ? AND is_active = TRUE').bind(userId).all()\r\n\r\n    if (!windows.results || windows.results.length === 0) {\r\n        return { is_in_window: false, users_online_now: 0 }\r\n    }\r\n\r\n    const currentWindow = windows.results.find((w: any) => {\r\n        if (w.day_of_week !== currentDay) return false\r\n        const windowEnd = w.start_hour + Math.floor(w.duration_minutes / 60)\r\n        return currentHour >= w.start_hour && currentHour < windowEnd\r\n    })\r\n\r\n    if (currentWindow) {\r\n        const onlineCount = await getActiveUsersCount(env, currentDay, currentHour)\r\n        return {\r\n            is_in_window: true,\r\n            current_window: currentWindow as unknown as VibeWindow,\r\n            users_online_now: onlineCount,\r\n        }\r\n    }\r\n\r\n    const nextWindow = findNextWindow(windows.results as unknown as VibeWindow[], currentDay, currentHour, currentMinute)\r\n\r\n    return { is_in_window: false, next_window: nextWindow, users_online_now: 0 }\r\n}\r\n\r\nfunction findNextWindow(windows: VibeWindow[], currentDay: number, currentHour: number, currentMinute: number): { starts_in_seconds: number; day: string; time: string } | undefined {\r\n    let minDiff = Infinity\r\n    let nextWindow: VibeWindow | undefined\r\n\r\n    for (const window of windows) {\r\n        let dayDiff = window.day_of_week - currentDay\r\n        if (dayDiff < 0) dayDiff += 7\r\n        if (dayDiff === 0 && window.start_hour <= currentHour) dayDiff = 7\r\n\r\n        const totalMinutes = dayDiff * 24 * 60 + (window.start_hour - currentHour) * 60 - currentMinute\r\n        if (totalMinutes > 0 && totalMinutes < minDiff) {\r\n            minDiff = totalMinutes\r\n            nextWindow = window\r\n        }\r\n    }\r\n\r\n    if (!nextWindow) return undefined\r\n\r\n    return {\r\n        starts_in_seconds: minDiff * 60,\r\n        day: DAYS[nextWindow.day_of_week],\r\n        time: `${nextWindow.start_hour}:00`,\r\n    }\r\n}\r\n\r\nasync function getActiveUsersCount(env: Env, day: number, hour: number): Promise<number> {\r\n    const result = await env.DB.prepare(\r\n        `SELECT COUNT(DISTINCT user_id) as count \r\n     FROM VibeWindows \r\n     WHERE day_of_week = ? \r\n     AND start_hour <= ? \r\n     AND (start_hour + duration_minutes / 60) > ? \r\n     AND is_active = TRUE`\r\n    ).bind(day, hour, hour).first()\r\n\r\n    return (result?.count as number) || 0\r\n}\r\n\r\nexport async function handleVibeWindows(request: Request, env: Env): Promise<Response> {\r\n    const userId = await verifyAuth(request, env);\r\n    if (!userId) throw new AuthenticationError();\r\n\r\n    const url = new URL(request.url);\r\n    const path = url.pathname;\r\n    const method = request.method;\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    try {\r\n        if (path === '/v2/vibe-windows/set' && method === 'POST') {\r\n            const body = await request.json();\r\n            const result = await setVibeWindows(env, userId, body);\r\n            return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n        }\r\n\r\n        if (path === '/v2/vibe-windows/status' && method === 'GET') {\r\n            const result = await getVibeWindowStatus(env, userId);\r\n            return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n        }\r\n    } catch (e: any) {\r\n        if (e instanceof z.ZodError) throw new ValidationError(e.errors[0].message);\r\n        throw e;\r\n    }\r\n\r\n    throw new AppError('Route not found', 404, 'NOT_FOUND');\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ireno\\Downloads\\Love Vibes\\apps\\backend\\src\\voice-matching.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2280,2283],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2280,2283],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3086,3089],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3086,3089],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":168,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":168,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5804,5807],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5804,5807],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":186,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6367,6370],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6367,6370],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":203,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":203,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7155,7158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7155,7158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Voice-First Matching System\r\n// Match based on voice before seeing photos\r\n\r\nimport { Env } from './index'\r\nimport { z } from 'zod';\r\nimport { AuthenticationError, ValidationError, AppError } from './errors';\r\nimport { logger } from './logger';\r\nimport { notifyNewMatch } from './notifications';\r\n\r\n// Zod Schemas\r\nconst VoiceSwipeSchema = z.object({\r\n    target_id: z.string().uuid(),\r\n    action: z.enum(['LIKE', 'PASS']),\r\n});\r\n\r\nexport interface VoiceProfile {\r\n    user_id: string\r\n    voice_url: string\r\n    duration: number\r\n    tone_score: number\r\n    pace_score: number\r\n    emotion_score: number\r\n    authenticity_score: number\r\n    transcription: string\r\n}\r\n\r\nexport interface VoiceFeedProfile {\r\n    user_id: string\r\n    voice_url: string\r\n    duration: number\r\n    waveform_data?: number[]\r\n    overall_score: number\r\n    photos_unlocked: boolean\r\n}\r\n\r\n// POST /api/voice/upload - Upload voice note\r\nexport async function uploadVoiceProfile(\r\n    env: Env,\r\n    userId: string,\r\n    audioFile: File\r\n): Promise<{ success: boolean; message: string; voice_url?: string }> {\r\n    try {\r\n        // Upload to R2\r\n        const fileName = `voices/${userId}/${Date.now()}.webm`\r\n        await env.MEDIA_BUCKET.put(fileName, audioFile)\r\n        const voiceUrl = `https://media.lovevibes.app/${fileName}`\r\n\r\n        // Analyze voice (REMOVED MOCK: Now uses Cloudflare Workers AI)\r\n        const analysis = await analyzeVoice(env, audioFile)\r\n\r\n        const now = Math.floor(Date.now() / 1000)\r\n\r\n        // Save voice profile\r\n        await env.DB.prepare(\r\n            `INSERT OR REPLACE INTO VoiceProfiles \r\n       (user_id, voice_url, duration, tone_score, pace_score, emotion_score, authenticity_score, transcription, created_at) \r\n       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`\r\n        )\r\n            .bind(\r\n                userId,\r\n                voiceUrl,\r\n                analysis.duration,\r\n                analysis.tone_score,\r\n                analysis.pace_score,\r\n                analysis.emotion_score,\r\n                analysis.authenticity_score,\r\n                analysis.transcription,\r\n                now\r\n            )\r\n            .run()\r\n\r\n        return { success: true, message: 'Voice profile created!', voice_url: voiceUrl }\r\n    } catch (error: any) {\r\n        throw new AppError('Failed to upload voice profile', 500, 'VOICE_UPLOAD_FAILED', error);\r\n    }\r\n}\r\n\r\n// GET /api/voice/feed - Get voice-only feed\r\nexport async function getVoiceFeed(\r\n    env: Env,\r\n    userId: string,\r\n    limit: number = 20\r\n): Promise<VoiceFeedProfile[]> {\r\n    // Get users with voice profiles that current user hasn't swiped on\r\n    const results = await env.DB.prepare(\r\n        `SELECT vp.user_id, vp.voice_url, vp.duration, vp.tone_score, vp.pace_score, vp.emotion_score\r\n     FROM VoiceProfiles vp\r\n     WHERE vp.user_id != ?\r\n     AND vp.user_id NOT IN (\r\n       SELECT target_id FROM VoiceSwipes WHERE actor_id = ?\r\n     )\r\n     ORDER BY RANDOM()\r\n     LIMIT ?`\r\n    )\r\n        .bind(userId, userId, limit)\r\n        .all()\r\n\r\n    return results.results.map((r: any) => ({\r\n        user_id: r.user_id,\r\n        voice_url: r.voice_url,\r\n        duration: r.duration,\r\n        overall_score: (r.tone_score + r.pace_score + r.emotion_score) / 3,\r\n        photos_unlocked: false,\r\n    }))\r\n}\r\n\r\n// POST /api/voice/swipe - Swipe on voice\r\nexport async function voiceSwipe(\r\n    env: Env,\r\n    actorId: string,\r\n    targetId: string,\r\n    action: 'LIKE' | 'PASS'\r\n): Promise<{ success: boolean; mutual_match: boolean; photos_unlocked: boolean }> {\r\n    const now = Math.floor(Date.now() / 1000)\r\n\r\n    try {\r\n        // Record swipe\r\n        await env.DB.prepare(\r\n            'INSERT INTO VoiceSwipes (actor_id, target_id, type, timestamp) VALUES (?, ?, ?, ?)'\r\n        )\r\n            .bind(actorId, targetId, action, now)\r\n            .run()\r\n\r\n        if (action === 'PASS') {\r\n            return { success: true, mutual_match: false, photos_unlocked: false }\r\n        }\r\n\r\n        // Check for mutual like\r\n        const mutualLike = await env.DB.prepare(\r\n            'SELECT * FROM VoiceSwipes WHERE actor_id = ? AND target_id = ? AND type = ?'\r\n        )\r\n            .bind(targetId, actorId, 'LIKE')\r\n            .first()\r\n\r\n        if (mutualLike) {\r\n            // Unlock photos for both users\r\n            await env.DB.prepare(\r\n                'UPDATE VoiceSwipes SET photos_unlocked = TRUE WHERE (actor_id = ? AND target_id = ?) OR (actor_id = ? AND target_id = ?)'\r\n            )\r\n                .bind(actorId, targetId, targetId, actorId)\r\n                .run()\r\n\r\n            // Create regular match\r\n            const matchId = crypto.randomUUID()\r\n            await env.DB.prepare(\r\n                'INSERT INTO Matches (id, user_a_id, user_b_id, created_at) VALUES (?, ?, ?, ?)'\r\n            )\r\n                .bind(matchId, actorId, targetId, now)\r\n                .run()\r\n\r\n            // Get user names for notification\r\n            const [actorUser, targetUser] = await Promise.all([\r\n                env.DB.prepare('SELECT name FROM Users WHERE id = ?').bind(actorId).first(),\r\n                env.DB.prepare('SELECT name FROM Users WHERE id = ?').bind(targetId).first()\r\n            ])\r\n\r\n            // Send push notifications to both users\r\n            await Promise.all([\r\n                notifyNewMatch(env, actorId, (targetUser?.name as string) || 'Someone'),\r\n                notifyNewMatch(env, targetId, (actorUser?.name as string) || 'Someone')\r\n            ])\r\n\r\n            logger.info('voice_match_created', undefined, { actorId, targetId, matchId });\r\n            return { success: true, mutual_match: true, photos_unlocked: true }\r\n        }\r\n\r\n        return { success: true, mutual_match: false, photos_unlocked: false }\r\n    } catch (error: any) {\r\n        throw new AppError('Failed to process voice swipe', 500, 'VOICE_SWIPE_FAILED', error);\r\n    }\r\n}\r\n\r\n// Real Voice Analysis using Cloudflare Workers AI\r\nasync function analyzeVoice(env: Env, audioFile: File): Promise<{\r\n    duration: number\r\n    tone_score: number\r\n    pace_score: number\r\n    emotion_score: number\r\n    authenticity_score: number\r\n    transcription: string\r\n}> {\r\n    try {\r\n        const audioArray = new Uint8Array(await audioFile.arrayBuffer());\r\n\r\n        // 1. Transcription using Whisper\r\n        const transcriptionResult: any = await env.AI.run('@cf/openai/whisper', {\r\n            audio: Array.from(audioArray)\r\n        });\r\n        const transcription = transcriptionResult.text || \"No transcription available\";\r\n\r\n        // 2. Intelligence Analysis using Llama 3.1\r\n        const prompt = `Analyze this voice transcription for a dating app profile. \r\n    Transcription: \"${transcription}\"\r\n    \r\n    Based on the text content, rate the following from 0 to 100 as a JSON object:\r\n    - tone_score (warmth and pitch variety inferred from wording)\r\n    - pace_score (confidence and flow inferred from wording)\r\n    - emotion_score (emotional resonance and vulnerability)\r\n    - authenticity_score (genuineness and honesty)\r\n    \r\n    Only return the JSON object, NO extra text.`;\r\n\r\n        const aiAnalysis: any = await env.AI.run('@cf/meta/llama-3.1-8b-instruct', {\r\n            messages: [{ role: 'user', content: prompt }]\r\n        });\r\n\r\n        let scores = { tone_score: 75, pace_score: 75, emotion_score: 75, authenticity_score: 85 };\r\n        try {\r\n            const content = aiAnalysis.response || aiAnalysis.content || \"\";\r\n            const cleaned = content.match(/\\{.*\\}/s)?.[0];\r\n            if (cleaned) {\r\n                scores = JSON.parse(cleaned);\r\n            }\r\n        } catch (e) {\r\n            logger.warn('voice_scoring_fallback', 'Using fallback scores due to AI parse error', { error: e });\r\n        }\r\n\r\n        return {\r\n            duration: Math.round(audioFile.size / 16000), // Very rough estimate for 16kbps mono\r\n            ...scores,\r\n            transcription\r\n        };\r\n    } catch (error) {\r\n        logger.error('voice_analysis_error', 'AI Voice Analysis Failed', { error });\r\n        return {\r\n            duration: 0,\r\n            tone_score: 50,\r\n            pace_score: 50,\r\n            emotion_score: 50,\r\n            authenticity_score: 50,\r\n            transcription: \"Analysis unavailable\"\r\n        };\r\n    }\r\n}\r\n\r\nexport async function handleVoiceMatching(request: Request, env: Env): Promise<Response> {\r\n    const { verifyAuth } = await import('./auth');\r\n    const userId = await verifyAuth(request, env);\r\n    if (!userId) throw new AuthenticationError();\r\n\r\n    const url = new URL(request.url);\r\n    const path = url.pathname;\r\n    const method = request.method;\r\n    const jsonHeaders = { 'Content-Type': 'application/json' };\r\n\r\n    if (path === '/v2/voice/upload' && method === 'POST') {\r\n        const formData = await request.formData();\r\n        const file = formData.get('file') as unknown as File;\r\n        if (!file) throw new ValidationError('Missing audio file');\r\n        const result = await uploadVoiceProfile(env, userId, file);\r\n        return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n    }\r\n\r\n    if (path === '/v2/voice/feed' && method === 'GET') {\r\n        const result = await getVoiceFeed(env, userId);\r\n        return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n    }\r\n\r\n    if (path === '/v2/voice/swipe' && method === 'POST') {\r\n        const body = VoiceSwipeSchema.parse(await request.json());\r\n        const result = await voiceSwipe(env, userId, body.target_id, body.action);\r\n        return new Response(JSON.stringify({ success: true, data: result }), { headers: jsonHeaders });\r\n    }\r\n\r\n    return new Response(JSON.stringify({ error: 'Route not found' }), {\r\n        status: 404,\r\n        headers: jsonHeaders\r\n    });\r\n}\r\n","usedDeprecatedRules":[]}]